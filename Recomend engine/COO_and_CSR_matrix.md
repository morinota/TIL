# はじめに
最近、kaggleの「H&M Personalized Fashion Recommendations」へ参加する為にレコメンデーション手法について勉強しているのですが、その際に「**ユーザ×アイテム(もしくはアイテム×ユーザ)の評価データ**」を扱う事が多々ありました。
ExplicitなデータであろうとImplicitなデータであろうと協調フィルタリングによるレコメンデーションにおいては、「**ユーザ×アイテム(もしくはアイテム×ユーザ)の評価データ**」すなわち"**評価行列(Rating Matrix)**"を使用していきます。
そして評価行列は基本的には疎行列のようです。
てっきり"行列"を扱うとなると、Pythonにおいてはnumpyのndarrayオブジェクトとして操作すれば良いかなと思っていたのですが、どうやら疎行列特有("ゼロ要素が多くを占める"という特性を活かした)のデータ格納形式があるらしく、疎行列の扱いについてある程度理解しておく必要があり、本記事で少々まとめることにしました：）


# まず疎行列(Sparse Matrix)とは？

- 成分のほとんどがゼロである行列を意味します。
  - 一般的な条件としては、非ゼロ要素の数が行数または列数におおよそ近い場合、その行列は疎行列(Sparse Matrix)であるといえるようです。
  - 逆にほとんどの要素が非ゼロ行列である行列は、密な行列(Dense Matrix)と見なされます。
- 行列のゼロ要素の数を要素数の合計で割った値を、行列のスパース性(Sparsity)と呼びます。

# 疎行列の格納形式
一般的に行列は、2次元の配列に格納されます。配列の各要素は、行列の要素$a_{i, j}$を表し、2つのインデックスiとjを用いてアクセスされます。
慣習として、iは上から下に数えた行のインデックスを指し、jは左から右に数えた列のインデックスを指します。また、例えば$m \times n$行列の場合、このフォーマットで行列を格納するのに必要なメモリ量は、$m\times n$に比例します。
(この"必要なメモリ量"を節約する事が、疎行列の格納形式におけるモチベーション、言い換えれば、疎行列独自の格納方式を用いる動機になります。)

疎行列の場合、**非ゼロ要素のみを保存する事で、必要メモリ容量の大幅な削減が実現できます**。
非ゼロ要素の数と分散によって、異なるデータ構造を利用することで、基本的なアプローチに比べてメモリ量の大幅な節約が可能になります。
デメリット(メリットとのトレードオフだが...)は、各要素へのアクセスがより複雑になる事、オリジナルの行列を曖昧さなく復元できるようにするためには、追加の構造が必要になる事です。

**疎行列の格納形式としては、以下の様々な形式(Format)が存在**します.
- 効率的な編集をサポートするフォーマット
  - DOK(Dictionary of keys)形式
    - (行, 列) をキーにして連想配列に入れる方式.
  - LIL(List of lists)形式
    - 行ごとにリストを作り、そのリストの中に (列, 値) のタプルを入れる方式.
  - COO(Coodinate, 座標)形式

- 効率的なアクセスと行列操作をサポートするフォーマット
  - CSR(圧縮行格納)形式
  - CSC(圧縮列格納)形式
  - BSR(ブロック圧縮行格納)：
    - ブロック疎行列(Block Sparse Matrix)に対して適切.

例として、以下の疎行列Aを考える.
$$ A =
\begin{bmatrix}
1 & 2 & 3 & 0 \\
0& 0 & 0 & 1 \\
2 & 0 &  0 & 2 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$
# COO Matrix(Coodinate, 座標形式)
[値, 行インデックス, 列インデックス] タプルの集合で行列を表現する方式.
行列Aの要素を座標（インデックス）とともに並べると...
```python
A  = [1 2 3 0 0 0 0 1 2 0 0 2 0 0 0 1] # 値
IA = [1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4] # 行インデックス
JA = [1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4] # 列インデックス
```
ここで「存在しない値をゼロ要素とする」と定めると、ゼロ要素を全て削除できる.
```python
A  = [1 2 3 1 2 2 1] # 値
IA = [1 1 1 2 3 3 4] # 行インデックス
JA = [1 2 3 4 1 4 4] # 列インデックス
```
これが、疎行列AのCOO形式による表現.
COO行列のゼロ要素を非ゼロに編集したい場合、後ろに非ゼロタプルを追加する(=A, IA, JAの後ろに要素, i, jを追加する)だけでよいため、**編集効率が良い**。

# CRS(Compressed Row Storage, 圧縮行格納)：
行インデックス配列を圧縮する方式. 別名は**CSR** matrix(Compressed Sparse Row).
CSR方式ではまず、2次元の行列を行方向に並べる.
次に「存在しない値をゼロ要素とする」と定め、ゼロ要素を全て削除する.この段階で行・列インデックスとともに並べると次のようになる.(=この段階ではCOO形式と一致？？)
```python
data = [1 2 3 1 2 2 1] # 値
IA   = [1 1 1 2 3 3 4] # 行インデックス
JA   = [1 2 3 4 1 4 4] # 列インデックス
```
ここで、行インデックス配列(IA)に着目する.
現在は各要素が明示的に行インデックスを持っているが、行の切れ目さえ分かっていれば、これらは自動的に導ける.
例えば、```IA[1] = IA[2] = IA[3] = 1```であるが、「1行目は1要素目から、2行目は4要素目から」とわかっていれば、```IA[1:4]=[1 1 1]```を即座に導ける。
これはCSR方式が**行ごとに並べたうえでゼロ要素を削除する規則**に由来している。

この行インデックス表現```IA[1:4]```は行headポインタの配列(=リスト内の行の先頭の場所)と見なせる.すなわち```indptr = [ptr_row_1 ptr_row2 ...]```である。
インデックスを直接示す配列は列インデックス配列JAのみになったので、これを```indices```と改名する.
```python
data    = [1 2 3 1 2 2 1] # 値
indices = [1 2 3 4 1 4 4] # 列インデックス
indptr  = [1 4 5 7]       # 行Headポインタ(+最後の行のTailポインタ?)
```
これが、疎行列AのCSR形式による表現である。

- メリット
  CSR形式は行へのアクセスに優れている.
  データ(要素)を ```data[indptr[1]:indptr[2]]``` で取得し、列インデックスを ```indices[indptr[1]:indptr[2]]``` で取得できる.（行インデックスは当然1）
- デメリット
  CSR形式は列へのアクセスに劣る.
  1列目にアクセスする場合、```indices```を全長走査し```indices[k] == 1```に該当する要素番号```k```をリストアップしたのち、行インデックスを得るために```indptr``` を走査して各 ```k``` に大して ```indptr[n] <= k <indptr[n+1]```を満たす```n```を見つける必要がある。

# 参考
- https://ja.wikipedia.org/wiki/%E7%96%8E%E8%A1%8C%E5%88%97