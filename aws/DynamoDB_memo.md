## refs

- noteのバッチ推論結果をDynamoDBに保存してる事例: https://note.com/mussso/n/nb662ad4e6d73

## note社のDynamoDB利用事例

- 概要: note記事レコメンド機能のAWSアーキテクチャをリファクタリングした話。
  - アーキテクチャの全体像。ざっくり以下の3種のプロセスを実行してる
    - モデル学習プロセス
    - モデルのバッチ推論プロセス
    - バッチ推論結果のDynamoDB登録プロセス
- 旧アーキテクチャの特徴
  - SQSを責任分界点として、**SQSの左側(consumer)がnoteリポジトリ、SQSの右側(Producer)がMLリポジトリ**、という風にGithubリポジトリが分かれている。
    - noteリポジトリ側のbatchサーバーは、SQSから下記のようなuser_id毎の推薦記事リストデータを受け取って、DynamoDBに登録する処理を実行している。

```
{
    "data":[
        [user_id1, [推薦記事id1, 推薦記事id2, ... 推薦記事id100]], 
        [user_id2, [推薦記事id1, 推薦記事id2, ... 推薦記事id100]],
        [user_id3, [推薦記事id1, 推薦記事id2, ... 推薦記事id100]],
        ...
    ]
}
```

### 旧アーキテクチャの問題点

- 1. noteリポジトリとMLリポジトリの責任分界点
  - 前者はRuby、後者はPythonで実装されている。
  - **パイプライン全体を改善したい場合には、RubyとPythonの両方が書けるエンジニアしか対応できないので、開発がやや難しくなる**。
- 2. スケジュール駆動
  - noteリポジトリ側のbatchサーバは、1時間おきにSQSを見にいくというアーキテクチャになっていた。
    - SQSメッセージがない場合でもメッセージを取得しにいくという**無駄な処理が発生**。
    - また、SQSに最新の推薦データが入ったとしても、noteリポジトリ側のbatchサーバーがSQSメッセージを取りに来るまでに待ち状態が発生。よって**作った推薦結果を即座にユーザーインターフェースに反映できない**。
  - (この観点は重要だ...!:thinking:)
- 3. 処理の失敗があまり想定されていない。
  - 内部的にリトライ処理はしているのですが、失敗したメッセージをどこかにキューイングしておく仕組みではないため、失敗したメッセージは実質無視されている。
- 4. スケールアップ構成
  - noteリポジトリ側はデカいインスタンスで一気にSQSのメッセージを吸い取ってDynamoDBに登録するようなアーキテクチャになっているため、**単一障害点**になっていた。
    - 単一障害点についてメモ!
      - もしこの1台のインスタンスが停止、故障など動作しなくなった場合、全体の処理が完全にストップしてしまう。
      - 

### リファクタリング後のアーキテクチャ

- バッチ推論結果のDynamoDB登録プロセスの処理をリファクタリングした。
  - 責任分界点だったSQSの次にLambdaを置いて、noteリポジトリ側のbatch処理を削除。

リファクタリング後の改善点

- 1. MLチームのみで改善が完結する
  - 以前は、**noteリポジトリとMLリポジトリの責任分解点が微妙だったことで**、パイプライン全体を改善したい場合には、RubyとPythonの両方が書けるエンジニアしか対応できない状態だった。
  - 今回のリファクタリングにより、**MLチーム側の環境で機能改善が完結するので、改善活動がしやすくなった**。
- 2. イベント駆動
  - 以前は、1時間おきにSQSを見にいくというスケジュール駆動なアーキテクチャだった。
    - そのデメリットは前述。
  - 今回のリファクタリングにより、SQS+Lambdaの構成にすることでイベント駆動なアーキテクチャに変更。
    - SQSに届いたメッセージはすぐLabmdaが起動してDynamoDBに登録されるので、**推薦結果をすぐにユーザへ提供できるようになった**。
