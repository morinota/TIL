## refs:

- [非同期処理を使いこなそう !](https://aws.amazon.com/jp/builders-flash/202206/master-asynchronous-execution-01/?awsf.filter-name=*all)
- [メッセージキュー: ジョブをバッチ処理してアプリケーションを分離するための非同期メッセージング](https://aws.amazon.com/jp/message-queue/)
- [Pub/Sub メッセージング](https://aws.amazon.com/jp/what-is/pub-sub-messaging/)

# 非同期処理ってなんだっけ?

- ブログ連載内での定義:

  - 「処理の結果を待つ必要が"ある"サービス呼び出し」= 同期処理
  - 「処理の結果を待つ必要が"ない"サービス呼び出し」= 非同期処理

- 同期処理の特徴:
  - リクエストに対するレスポンスで処理結果を受取り、その処理結果を持って次の処理を行うことができる。
  - 一方で、時間のかかる処理を同期処理で呼び出すと、応答時間に影響が出てユーザ離脱や満足度低下につながる。
- 非同期処理の特徴:
  - **リクエストの受付と処理の実施を分離できる**。
    - 処理の完了を待つことなく、受付の完了のみを応答するため、ユーザに対するlatencyの改善や処理能力の改善を図れる。
  - ちなみに、HTTPのプロトコル仕様では **「202 Accepted」のHTTPステータスコード**が定義されてる...!
    - これは「リクエストは受け付けられたが、処理はまだ実施されていない」という意味。
    - このHTTPステータスコードを返すことで、処理が非同期で実施されることをリクエスト側に示すことができる。
  - (リクエストを一旦キューに入れて、一時応答だけレスポンスするイメージ!:thinking:)
    - もちろん、**キューは全てのリクエスト数に対応できるスケーラビリティや可用性が求められる**...!

# 非同期処理と同期処理の処理構造

- 前置き:
  - 非同期処理も、複数のモジュール間での処理リクエスト、実際の処理の実行、及び結果の応答の結合度を弱め疎結合化し、「応答性能(latency...?)」「ロバスト性」「信頼性」の向上や「影響範囲の限定化」を行い、最終的にはそのモジュールを使って実現したいビジネス価値を生み出す事が目的...!
    - **「非同期化」や「疎結合化」は手段! それがどのような成果につながるか考えよう**...!

## 同期処理/非同期処理の選択:

- hoge

## 同期処理/非同期処理のステップの違い:

## 非同期処理の構成:

- 以下の非同期処理を実装するうえで登場する2つの概念。
  - **キュー(Queue)**
  - **トピック(Publish/Subscribe)**
  - (説明軽く読んだ感じ、**QueueとTopicの違いはメッセージの受信者側の動き**。Queueの場合は受信者側からメッセージを確認しにいく必要がある。一方で、トピックの場合は予め登録された受信者にメッセージを発行する:thinking:)
- キューやトピックを利用する事で、プロセス間(ソフトウェア間)のつながりを疎結合(Loosely coupled)にする事ができる。

### キュー(Queue):

### トピック(Publish/Subscribe):

### キューとトピックの使い分け:

- 大きく違うのは、メッセージの受信者側の動き:

  - 1. メッセージの受信方法:
    - Queue: 受信者によるポーリング
    - Topic: 受信者による事前のSubscribe(登録)
  - 2. メッセージの受信者:
    - Queue: ポーリングした1プロセス(基本的に単一のプロセス)
    - Topic: 予め登録された複数のプロセス
  - 3. メッセージの受信タイミング:
    - QUeue: 受信者がポーリングしたタイミング(送信者が送信したタイミングとは限らない)
    - Topic: 基本的には、送信者がメッセージ発行リクエストをした直後
      - (Topicはメッセージ発行要求を受け取ったらすぐにsubscriberにメッセージするのか...!:thinking:)

- QueueとTopicの使い分けの例:
- ex.1)
- ex.2)
- ex.3)
- ex.4)
- ex.5)
