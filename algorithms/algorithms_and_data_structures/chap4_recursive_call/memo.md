# 再帰と分割統治法

## what is recursive??

- 再帰呼び出し(recursive call): 手続きの中で自分自身を呼び出すこと
- 再帰関数(recursive function): 再帰呼び出しを行う関数。

## 再帰関数の構成要素

- 再帰関数のテンプレートは以下:

```python
def func(引数)->返り値の型:
    if (ベースケース):
        return ベースケースに対する値

    # recursive callを行う。
    func(次の引数)
    return 答え
```

- ベースケース: 再帰関数の中でrecursive callを行わずにreturnするケースのこと。
  - ベースケースの処理を行わないとrecursive callを無限に繰り返すことになる。このベースケースに対する処理が重要。
    - recursive callが止まらない場合、実際にはrecursive callを行う度にスタック領域をつぶしてメモリを消費していく。->有限資源を採用してる限りはどこかのタイミングでstack overflowを起こす。
  - もう一つのポイントは、recursive callを行った時の引数が、ベースケースに近づくようにすること。

## メモ化して動的計画法へ

- 実は例2の実装は、同じ計算を何度も実行していて効率が悪い。
  - `fibo(N)`の計算量は、$O((\frac{1+\sqrt{5}}{2})^{N})$。$N$について指数関数的に計算量が増える。
- しかし一方で、forループを用いた反復法では $O(N)$の計算量で済む。再帰関数のどこに原因がある??
  - -> 同じ計算を何度も実行しているから!
- -> 「**同じ引数に対するrecursive callの返り値をメモ化する**」方法が有効...!
  - いわゆる"キャッシュ"と呼ばれる考え方。
  - メモ化によって、計算量は $O(N)$になる。
- このメモ化は、動的計画法フレームワークを再帰関数を用いて実現したものとみなせる。
  - 例では簡単のため、グローバル変数としているが、実際にはグローバル変数の乱用は非推奨。よって対策として、memoを再帰関数の参照引数とする等の工夫が考えられる...!

## 再帰関数を用いる全探索:

- 再帰関数を採用する事で、複雑な対象に対しても明快な探索アルゴリズムを記述できる。
- 例4 部分和問題

## 分割統治法(devide-and-conquer method)

- 再帰を活用したアルゴリズム設計技法である。
- 例: 部分和問題に対する再帰を用いた解法を振り返る:
  - N個の整数についての問題を、N-1個の整数に関する**2つの小問題へと分割**した。
  - この分割をN-2個の整数の小問題、N-3個の整数の小問題, ...へと再帰的に繰り返した。
- ->例のように、**与えられた問題をいくつかの部分問題に分解し、各部分問題を再帰的に解き、それらの解を組み合わせて元の問題の解を構成するアルゴリズム技法**を、分割統治法(devide-and-conquer method)と呼ぶ。
  - 非常に基本的な考え方。
  - これが進化を発揮するのは、すでに多項式時間アルゴリズムが得られている問題にたいして、より高速なアルゴリズムを設計する為に、分割統治法を意識的に用いること。
    - ex. 計算量 O(n^2)のソートアルゴリズム -> 分割統治法に基づくマージソート (計算量は $O(N \log N)$)
  - ちなみに、分割統治法に基づくアルゴリズムの計算量を解析する際は、しばしば入力サイズ $N$ に関する計算時間 $T(N)$ に関する漸化式を考える。
