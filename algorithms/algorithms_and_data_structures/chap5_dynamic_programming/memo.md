# 動的計画法(dynamic_programming, DP)

- 抽象的には、「与えられた問題全体を**一連の部分問題に上手に分解**し、**各部分問題に対する解をメモ化**しながら、**小さな部分問題からより大きな部分問題へと順に**解を求めていく」手法。
  - 分割統治法の部分集合??:thinking:
  - いかにF「一連の部分問題に上手に分解」するかが肝となる。
- メモ化再帰は、DPを再帰関数を用いて実現したものとみなせる。
- DPを用いて効率的に解ける問題はたくさんあり、分野横断的に適用可能な方法論である:
  - ナップサック問題
  - スケジューリング問題
  - 発電計画問題
  - 編集距離
  - 音声認識パターンマッチング問題
  - 文章の分かち書き
  - 隠れマルコフモデル

## 簡単な例題で、DPにおける諸概念を整理する:

- Frog問題を例題とする。
- 対象物の関係性を「丸」と「矢印」で表したものをグラフと呼ぶ。
  - 「丸」=頂点、「矢印」=辺と呼ぶ。
  - **解きたい問題を、グラフの問題として定式化し直す**ことで、見通しが良くなる。
- 解法のポイント1:
  - 「頂点iに至る最小コストを求める」という「大きな」問題を、以下の2つの「小さな」部分問題に分解したこと。
    - 頂点i-1に至る最小コストを求める。
    - 頂点i-2に至る最小コストを求める。
- - 解法のポイント2:
  - 「頂点i-1にたどり着く方法は無数にあるが、そのうちコストが最小のものだけを考えれば良い」という点。
    - もし、頂点iへ至る最小コストの経路Pが存在して、Pの直前の移動までの部分についても最小コストを達成してる必要がある。
  - -> このように「元の問題の最適性を考えるときに、小さな部分問題についても最適性が要請される」という構造を、**部分構造最適性(optimal substructure)**と呼ぶ。
  - ->**部分構造最適性を利用して、各部分問題に対する最適値を順に決定していく手法 = DP**。

## DPにおける諸概念:

- 緩和(relaxation):

  - DPの中核概念。配列dpに各値Dが徐々に小さい値へと更新されていくイメージ。
    - (=部分問題をどんどん小さくしていき、小さい問題から最適化していくってこと??:thinking:)
    - (たぶん違って、**メモ化した値を徐々に最適値に近づくように更新していく**ってことだと思う。:thinking:)
  - 一般に、グラフ上で頂点uから頂点vへと遷移する辺があって、その遷移のコストをcと表した時に、`dp[v] = choose_minimum(dp[v], dp[u]+c)`とする処理を、その辺に関する**緩和(relaxation)**と呼ぶ。

- 貰う遷移形式(pull-based)と配る遷移形式(push-based):

  - DPの緩和のパターンとしては以下の2種類が考えられる。
  - pull-based:
    - 「頂点iに対して向かってくる遷移を考える」という形式
    - ex.) dp[i-1]やdp[i-2]の値が確定している時に、その値を用いてdp[i]の値を更新する。
  - push-based:
    - 「頂点iから伸びていく遷移を考える」という形式。
    - ex.) dp[i]の値が確定している時に、その値を用いてdp[i+1]やdp[i+2]の値を更新する。

- メモ化再帰:
  - 「探索過程をまとめる」という考え方は、まさにDPそのもの。

## DPの例2: ナップサック問題

- 実際にナップサック問題を解こうとするときには，DP以外にもさまざまな解決の選択肢があることを意識することが重要。
- DPの部分問題の作り方の基本パターン:
  - N個の対象物 {0, 1, ..., N-1}に関する問題に対して、**最初のi個の対象物{0,1,...,i-1}に関する問題**を部分問題として考える。
- 0,1,...,i-1番目の品物からいくつか選んだ後に、i番目の品物を選ぶor選ばないの2通りの選択肢がある。
  - -> このような「**各段階においていくつかの選択肢が存在する」状況**は、DPを有効に適用できそう...!
  - これを踏まえて、dpテーブルの定義を考えてみる。
    - ->dp[i] <- 最初のi個の品物{0, 1, ..., i-1}までの中から重さがWを超えないように選んだ時の、価値の総和の最大値。
  - しかしこのままでは、部分問題 間の遷移を作れずに詰まってしまう...
    - dp[i] ->dp[i+1]への遷移を考える時、品物iを加えるようにした時に、重さの合計がWを超えるかどうかがわからない。
- この問題を解決する為に、dpテーブル(キャッシュ)の定義を以下のように変更する。
  - ->dp[i][w] <- 最初のi個の品物{0, 1, ..., i-1}までの中から重さがwを超えないように選んだ時の、価値の総和の最大値。
  - このように、**考案したdpテーブル設計で上手く遷移が作れなかった場合に、添字を付け加える事で遷移が成立するようにする**作業をしばしば行う...!
    - (i.e. key-valueキャッシュのkeyに条件を付け加えるイメージ:thinking:)
  - 「添字を付け加える」=選択肢をまとめあげる粒度を細かくする事。**グループ間の遷移をきちんと作れる程度に、ギリギリの粒度を突き詰める事**がDPの醍醐味...!

## DPの例3: 編集距離

- 例1,2は、「N個の対象物に関する問題に対して、最初のi個に関する問題を部分問題として、iを進めながら更新していく」タイプのDPだった。
  - -> 例3は発展系として、**系列(=sequence??)が複数あって、系列に沿って進める添字も複数あるようなケース**を見ていく...!
- 例3では、編集距離(edit distance)を考える。
  - 2つの文字列 S, Tの類似度を図る。(文字列はsequenceの一種:thinking:)
  -
