## refs:

- pydantic-settingsの公式ドキュメント: [Settings management](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)
-

# Pydantic Settings

## なにそれ?

> Pydantic Settings provides optional Pydantic features for loading a settings or config class from environment variables or secrets files.
> Pydantic Settingsは、**環境変数やシークレットファイルから設定やconfigクラスをロードするための**Pydanticのオプション機能を提供します。

# Usage

- BaseSettingsクラス
  - `BaseSettings`を継承したモデルを作成する場合、キーワード引数として渡されなかったfieldの値を環境から読み込んで決定しようとする。
  - matchする環境変数がない場合、デフォルト値が使われる。
- どんな恩恵がある??
  - clearly-definedな(明確に定義された)、type-hintedなアプリケーションconfigクラスを簡単に作成できる。
  - 環境変数から、configurationの変更を自動的に読み込むことができる。
  - configクラスの初期化時に、必要に応じて(単体テスト時など)、特定のfieldを手動で簡単に上書きできる。

例

```python
from typing import Any, Callable, Set

from pydantic import (
    AliasChoices,
    AmqpDsn,
    BaseModel,
    Field,
    ImportString,
    PostgresDsn,
    RedisDsn,
)

from pydantic_settings import BaseSettings, SettingsConfigDict


class SubModel(BaseModel):
    foo: str = 'bar'
    apple: int = 1


class Settings(BaseSettings):
    auth_key: str = Field(validation_alias='my_auth_key')

    api_key: str = Field(alias='my_api_key')

    redis_dsn: RedisDsn = Field(
        'redis://user:pass@localhost:6379/1',
        validation_alias=AliasChoices('service_redis_dsn', 'redis_url'),  (3)
    )
    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'
    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'

    special_function: ImportString[Callable[[Any], Any]] = 'math.cos'  (4)

    # to override domains:
    # export my_prefix_domains='["foo.com", "bar.com"]'
    domains: Set[str] = set()

    # to override more_settings:
    # export my_prefix_more_settings='{"foo": "x", "apple": 1}'
    more_settings: SubModel = SubModel()

    model_config = SettingsConfigDict(env_prefix='my_prefix_')  (5)


print(Settings().model_dump())
"""
{
    'auth_key': 'xxx',
    'api_key': 'xxx',
    'redis_dsn': Url('redis://user:pass@localhost:6379/1'),
    'pg_dsn': MultiHostUrl('postgres://user:pass@localhost:5432/foobar'),
    'amqp_dsn': Url('amqp://user:pass@localhost:5672/'),
    'special_function': math.cos,
    'domains': set(),
    'more_settings': {'foo': 'bar', 'apple': 1},
}
"""
```

- 補足:
  - 1. `AliasChoices`クラスは、1つのfieldに対して複数の環境変数名を設定できる。最初に見つかった環境変数が使われる。
  - 2. `ImportString`は、文字列をオブジェクトをimportできる。
    - この例では、環境変数`special_function`が読み込まれ、関数`math.cos`がimportされる。
  - 3. `env_prefix` configにより、全ての環境変数のprefixを設定できる。(`dev-`や`prod-`とか??)

## Validation of default values(デフォルト値のvalidation)

- pydantic.BaseModelとは異なり、`pydantic_settings.BaseSettings`は、デフォルト値のvalidationをデフォルトで行う。
  - `model_config`で`validate_default=False`と設定する、もしくは各fieldで`Field(validate_default=False)`と設定することで、validationを無効にできる。
  - (ここで、"default値のvalidation"とは、デフォルト値がfieldの型に適合しているかどうかのvalidationの事...??:thinking_face:)

```python
from pydantic import Field

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(validate_default=False) # 全fieldに対してvalidationを無効にする

    # default won't be validated
    foo: int = 'test' # fooはint型なのに、str型のデフォルト値が設定されている状況...!!

class Settings1(BaseSettings):
    # default won't be validated
    foo: int = Field('test', validate_default=False) # field単位でvalidationを無効にすることもできる
```

## Environment variable names (環境変数名の扱い)

- **デフォルトでは、環境変数名はフィールド名と同じ**。
- すべての環境変数のprefixを設定したい場合:
  - `env_prefix` 設定か、インスタンス生成時の`env_prefix`キーワード引数で設定できる。
  - `env_prefix`のデフォルト値は空文字列``。

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix='my_prefix_') # 前者の設定方法

    auth_key: str = 'xxx'  # will be read from `my_prefix_auth_key`
```

- 特定のfieldの環境変数名を設定したい場合は、Aliasを使う事ができる。
  - 方法1. `Field(alias=...)`を使う。
  - 方法2. `Field(validation_alias=...)`を使う。
- Aliasを設定されたfieldに対しては、`env_prefix`の設定は適用されなくなる。
  - Aliasを設定する場合、環境変数名がfield Aliasと同一である必要がある。

```python
from pydantic import Field

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix='my_prefix_')

    foo: str = Field('xxx', alias='FooAlias')  # will be read from `FooAlias`
```

## 大文字小文字の扱い(Case sensitivity)

- デフォルトでは、環境変数名は大文字小文字を区別しない。
- もし環境変数名の大文字小文字を区別したい場合、`case_sensitive`configを`True`に設定する。
  - ネストされたモデルの場合、この`case_sensitive`設定は全てのネストされたモデル達に適用される。

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(case_sensitive=True)

    redis_host: str = 'localhost'
```

## Parsing environment variables values

- デフォルトでは、環境変数は値が空の場合も含めてそのまま解析される。
  - `env_ignore_empty` configを`True`に設定することで、空の環境変数を無視することができる。
    - -> 環境変数の空の値ではなく、フィールドのデフォルト値を使いたい場合に便利! (たぶん環境変数は存在するけど空文字列のケースとか??:thinking:)
- parseのロジック:
  - int, float, str型などのシンプルなfield型の場合、環境変数の値は文字列として解析される。
  - list, set, dict, sub model型のように複雑なfield型の場合、環境変数の値はJSON encodeされた文字列として解析される。
    - ネストした複雑な変数に値を入れるもう一つの方法は、`env_nested_delimiter` configを設定すること。
      - この場合 `FOO__BAR__BAZ=123`という環境変数は、`FOO={'BAR': {'BAZ': 123}}`という値とみなして解析される。
        - (後述の例を見る感じでは、複数matchする場合はこちらが優先されるっぽい??:thinking:)
  - **サブモデルはpydantic.BaseModel を継承しなければならない**。(なるほど...? 一番上のモデルだけBaseSettingsを継承する感じ??)
    - そうしないと、pydantic-settingsは、sub modelを初期化しsub modelのfieldを個別に収集しようとする。

例:

```shell
# your environment
export V0=0
export SUB_MODEL='{"v1": "json-1", "v2": "json-2"}'
export SUB_MODEL__V2=nested-2
export SUB_MODEL__V3=3
export SUB_MODEL__DEEP__V4=v4
```

この場合、settings modelは以下のようにparseしてloadされる:

```python
from pydantic import BaseModel

from pydantic_settings import BaseSettings, SettingsConfigDict


class DeepSubModel(BaseModel):
    v4: str


class SubModel(BaseModel):
    v1: str
    v2: bytes
    v3: int
    deep: DeepSubModel


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_nested_delimiter='__')

    v0: str
    sub_model: SubModel


print(Settings().model_dump())
"""
{
    'v0': '0',
    'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},
}
""" # v2の値を見ると、env_nested_delimiter設定でmatchした値のほうが、優先されていることがわかる...!
```

- 補足:
  - nestされた値の環境変数は、top-levelの環境変数jsonよりも優先される!

## Dotenv (.env)への対応
