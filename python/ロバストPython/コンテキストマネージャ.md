## 何それ?

- Pythonでは、**ある操作を終えた際に自動的になんらかの関数が呼び出されるようにしたい場面**がよくある。
  - ex. 外部データソースへのアクセス(ファイルのcloseやDBアクセスのsession終了)
- この場合に、Pythonで使われるのが**withブロック**。
  - ブロック内の処理が終了すると同時に、withブロックの先頭で指定された関数が呼び出される。
- そのwithブロックを利用するためにPythonが提供するオブジェクトが、**コンテキストマネージャ**!
  - `@contextmanager`でデコレートされた関数は、コンテキストマネージャとなり、withブロックで使えるようになる。

## コンテキストマネージャの挙動

```python
from contextlib import contextmanager

@contextmanager
def my_context_manager(x: int, y: int)->int:
    try:
        print("withブロックの前に実行される部分")
        yield x + y
    finally:
        print("withブロックの後に実行される部分")

with my_context_manager(1, 2) as sum_value:
    print(f"sum_value: {sum_value}")


>>> withブロックの前に実行される部分
>>> sum_value: 3
>>> withブロックの後に実行される部分
```

- `@contextmanager`デコレータを使って、コンテキストマネージャを定義。
- 値をyieldすると、関数に割り込みがかかり、呼び出し元コードに値が返される。
- withブロック内のコードが終了すると、実行はyield文のすぐ下に戻る。
  - **呼び出し元コードが例外を送出しても、最後まで正常に実行されてもそれは変わらない**。

## コンテキストマネージャがなぜ必要かの考え方!

- 利用者がオブジェクトを使い終わった後、ユーザは必要な作業を省略してしまうエラーが発生し得る。
- 省略のエラーは簡単に生じる。
- 利用者が何もしなくても、コンテキストマネージャが利用者に代わって正しいことをする。
  - **利用者が気づかないうちに正しいことが実行されるのは、コードベースがロバストであることを示すシグナルだ...!!** (確かに...!!)

