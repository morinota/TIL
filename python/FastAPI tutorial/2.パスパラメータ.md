# パスパラメータ

Pythonの**format文字列と同様のシンタックス**で「パスパラメータ」や「パス変数」を宣言できる。

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}") # ここ！
async def read_item(item_id):
    return {"item_id": item_id}
```

パスパラメータ item_id の値は、引数 item_id として関数に渡される。
しがたって、この例を実行して http://127.0.0.1:8000/items/foo にアクセスすると、次のレスポンスが表示される。

```
{"item_id":"foo"}
```

## パスパラメータと型

- 標準のPythonの型アノテーションを使用して、関数内のパスパラメータの型を宣言できる
  - **型宣言により、関数内でのエディターサポート (エラーチェックや補完など) が提供**される！

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}
```

## データ変換

この例を実行し、ブラウザで http://127.0.0.1:8000/items/3 を開くと、次のレスポンスが表示される。

- 関数が受け取った（および返した）値は、文字列の "3" ではなく、Pythonの int としての 3 であることに注意
- したがって、型宣言を使用すると、FastAPIは自動リクエスト "解析" を行う。

## データバリデーション

しかしブラウザで http://127.0.0.1:8000/items/foo を開くと、次のHTTPエラーが表示される。

```json
{
  "detail": [
    {
      "loc": ["path", "item_id"],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ]
}
```

- これは、パスパラメータ item_id が int ではない値 "foo" だから!
- http://127.0.0.1:8000/items/4.2 で見られるように、intのかわりに float が与えられた場合にも同様なエラーが表示される。

確認

- 従って、Pythonの型宣言を使用することで、FastAPIはデータのバリデーションを行う。
- 表示されたエラーには問題のある箇所が明確に指摘されていることに注意。
- これは、APIに関連するコードの開発およびデバッグに非常に役立つ。

## ドキュメント

そしてブラウザで http://127.0.0.1:8000/docs を開くと、以下の様な自動的に生成された対話的なドキュメントが表示されます。

- 繰り返しになりますが、Python型宣言を使用するだけで、FastAPIは対話的なAPIドキュメントを自動的に生成する（Swagger UIを統合）
- パスパラメータが整数として宣言されていることに注意

## 標準であることのメリット、ドキュメンテーションの代替物

- また、生成されたスキーマが OpenAPI 標準に従っているので、互換性のあるツールが多数ある。
- このため、FastAPI自体が代替のAPIドキュメントを提供します（ReDocを使用）。
  - これは、 http://127.0.0.1:8000/redoc にアクセスすると確認できる。
- 同様に、互換性のあるツールが多数あります（多くの言語用のコード生成ツールを含む）

## Pydantic

- すべてのデータバリデーションは Pydantic によって内部で実行されるため、Pydanticの全てのメリットが得られます。
- str、 float 、 bool および他の多くの複雑なデータ型を型宣言に使用できます。
- これらのいくつかについては、チュートリアルの次の章で説明

## 順序の問題

- path operations を作成する際、固定パスをもつ状況があり得ます。
  - `/users/me` から、現在のユーザに関するデータを取得するとします。
  - さらに、ユーザIDによって特定のユーザに関する情報を取得するパス `/users/{user_id}` ももつことができます。
  - path operations は順に評価されるので、 `/users/me`が `/users/{user_id}` よりも**先に宣言されているか**確認する必要があります:

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/users/me")
async def read_user_me():
    return {"user_id": "the current user"}


@app.get("/users/{user_id}")
async def read_user(user_id: str):
    return {"user_id": user_id}
```

それ以外の場合、 /users/{users_id} は /users/me としてもマッチします。値が「"me"」であるパラメータ user_id を受け取ると「考え」ます。

# 定義済みの値

パスパラメータを受け取る path operation をもち、**有効なパスパラメータの値を事前に定義したい場合**は、標準のPython `Enum` を利用できる。

- 上の章では、intであれば何でもパスパラメータを受け取る事ができていた。
- 今度はそれを指定したい！って話！

## `Enum`クラスの作成

- `Enum` をインポートし、 `str` と `Enum` を継承したサブクラスを作成します。
  - `str` を継承することで、APIドキュメントは値が `文字列` でなければいけないことを知り、正確にレンダリングできるようになります。
- そして、固定値のクラス属性を作ります。すると、その値が使用可能な値となります:

```python
from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum): # ここ！
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name == ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

```

## パスパラメータの宣言

次に、作成したenumクラスである`ModelName`を使用した型アノテーションをもつパスパラメータを作成します:

```python
# 省略！

@app.get("/models/{model_name}")
async def get_model(model_name: ModelName): # ここ！
    if model_name == ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}
```

## ドキュメントの確認

**パスパラメータの利用可能な値が事前に定義されている**ので、対話的なドキュメントで適切に表示できます:

## Python列挙型の利用

パスパラメータの値は列挙型メンバとなります。

### 列挙型メンバの比較

これは、作成した列挙型 `ModelName` の列挙型メンバと比較できます:

### 列挙値の取得

`model_name.value` 、もしくは一般に、 `your_enum_member.value` を使用して実際の値 (この場合は str) を取得できます。

```python
# 例えば...
model_name.value
ModelName.alexnet.value

```
### 列挙型メンバの返却
path operation から列挙型メンバを返すことができます。JSONボディ（`dict` など）でネストすることもできます。

それらはクライアントに返される前に適切な値 (この場合は文字列) に変換されます。

# パスを含んだパスパラメータ

パス `/files/{file_path}` となる path operation を持っているとしましょう。

ただし、 `home/johndoe/myfile.txt` のようなパスを含んだ `file_path`(=パスパラメータ) が必要です。

したがって、URLは `/files/home/johndoe/myfile.txt` の様になります。

## OpenAPIサポート
- OpenAPIはテストや定義が困難なシナリオにつながる可能性があるため、内部にパスを含むパスパラメータの宣言をサポートしていません。
- それにも関わらず、Starletteの内部ツールのひとつを使用することで、FastAPIはそれが実現できます。
- そして、パラメータがパスを含むべきであることを明示的にドキュメントに追加することなく、機能します。

## パス変換
Starletteのオプションを直接使用することで、以下のURLの様なパスを含んだ、パスパラメータの宣言ができます:
`/files/{file_path:path}`

この場合、パラメータ名は `file_path` です。そして、最後の部分 `:path` はパラメータがいかなるパスにもマッチすることを示します。

したがって、以下の様に使用できます:
```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/files/{file_path:path}") # ここ！
async def read_file(file_path: str):
    return {"file_path": file_path}

```

- 最初のスラッシュ (/)が付いている `/home/johndoe/myfile.txt` をパラメータが含んでいる必要があります。
- この場合、URLは files と home の間にダブルスラッシュ (//) のある、 `/files//home/johndoe/myfile.txt` になります。
# まとめ

簡潔で、本質的で、標準的なPythonの型宣言を使用することで、FastAPIは以下を行う：

- エディタサポート：
- データ「解析」
- データバリデーション
- APIアノテーションと自動ドキュメント生成

そしてこれはたった一度宣言するだけ。
これは恐らく、(パフォーマンスを除いて) 他のフレームワークと比較したときの、FastAPIの主な目に見える利点。

# リンク

- https://fastapi.tiangolo.com/ja/tutorial/path-params/
