

## 継続的デリバリーの3つの基盤(foundations)について

継続的デリバリーは、以下の**3つの基盤**に基づいている。

- 1. 包括的な設定管理(comprehensive configuration management)
- 2. 継続的インテグレーション(continuous integration)
- 3. 継続的テスト(continuous testing)

### 基盤1: 包括的な設定管理(configuration management)について

- ソフトウェアを反復的にかつ信頼性高くリリースすることを保証する上で、**自動化は重要な役割を果たす**。
  - 自動化が果たす重要な役割の1つ
    - -> ビルド、デプロイ、退行テスト、インフラプロビジョニング(インフラのリソースを予測して提供すること?)のような、繰り返しの多い手作業プロセスを自動化すること。
    - -> これを実現するためには、**これらのプロセスを実行するために必要な全てのものをバージョン管理する必要がある**。
      - ex. ソースコード、テスト及びデプロイメントスクリプト、インフラおよびアプリケーションのconfig、依存する多くのライブラリやパッケージ, etc...
      - (version管理の重要さって、自動化するためなのか...!:thinking:)
    - また、ソフトウェア環境の現在と過去の状態を簡単に紹介できるようにしたい、というモチベーションもある。
      - (うん、これはversion管理のメリットとして想像しやすい:thinking:)
- configurationに関して、2つの最優先目標がある。
  - 1. **再現性(Reproducibility)**
    - 完全に自動化された方法で、どのような環境でもソフトウェアをビルド・デプロイ・テストでき、**同じconfigurationから再現される新しい環境は全て同じ結果を返す**ようにする必要がある。
  - 2. **追跡性(Traceability)**
    - 任意の環境を選んだときに、**その環境を作成するために使用された全ての依存関係のバージョンを迅速かつ正確に特定できる**ようにする必要がある。
    - また、任意の環境の過去のバージョンを比較し、**その間に何が変更されたかを特定できるようにする**必要がある。

- 達成したい上記の2つの能力(再現性、追跡性)は、開発組織に以下の重要な利点を与えてくれる:
  - 1. 迅速な災害復旧(disaster recovery)
  - 2. 高い監査可能性(Auditability)
  - 3. より高い品質(higher quality)
    - ソフトウェアのデリバリープロセスでは、開発・テスト・本番環境の準備を待つために、長い遅延が発生することがよくある。
    - これらを**バージョン管理から自動的に行うことができれば、変更影響に対するfeedbackをより迅速に得ることができ、ソフトウェアに品質を組み込むことができる**...!
  - 4. 容量管理(capacity management):
    - インフラの定義をバージョニング
  - 5. 欠陥への迅速な対応(quick response to defects)
    - システムに欠陥や脆弱性が見つかった時、できるだけ早くソフトウェアの新バージョンをリリースしたい。
      - 多くの組織では、緊急リリースのためのプロセスを持ってる。(ex. テストや監査の一部をバイパス、スキップする)
      - しかしこれは、safety-criticalなアプリケーションにおいて深刻なジレンマをもたらす。(テストスキップしちゃってるからじゃん...!:thinking:)
    - **理想的には、緊急リリースに通常のリリースプロセスが適用できるようになってることが望ましい! これが、包括的なconfiguration managementによって継続的デリバリーが実現したいこと...!**

- 全てのconfigをversion管理したいと言いつつも、完璧な再現性と追跡性を達成する事は不可能。
  - (version管理できない状態がどうしても存在するってことかな...!:thinking:)
  - **従って、configuration管理の重要なポイントは、投資に対して利益をより多く得るために、アーキテクチャ & 実行環境 & プロセスの単純化に取り組むこと...!!**
    - 投資(i.e. 費用) = 全てのconfig情報をversion管理するためのコスト
    - 利益(i.e. 効果) = 高い再現性と追跡性を達成することで得られるpositiveな効果

- 利益を達成するために努力する場合、我々は常に、**達成したい目標を測定可能な言葉で定義することから始めるべき**。
  - -> 目標に到達するための可能な経路のうち、最も良いものが何かを判断し、アプローチが高価すぎるか、時間がかかりすぎることがわかった場合には、**方向を変えたり、目標を再評価したりすることができる**。
    - (ABテストにおいてもmetricsを検討・feedbackを経て推敲し続けることが大事、みたいな話があったなぁ:thinking:)

#### FAQ

- どんなツールを使えば良い?
  - 多くの場合(全く適さないものを使わない限り)、道具の選択は成功の決定的な要因ではない。
- コンテナ/クラウド/仮想化技術は、このトピックにどのように影響する??
  - 最も重要なことは、**新たな進歩があるたびに、前述したような利益を、より簡単により安く達成できるようになる**ということ。
  - しかし、それ自体が特効薬というわけではない。
  - 我々が目標を達成するためには、引き続きバージョン管理とデプロイメント・パイプラインの包括的な使用の原則を適用する必要がある。

### 基盤2: 継続的インテグレーションについて

- **大前提、複数の開発者の仕事を組み合わせるのは難しい**。（これがCIのoriginなのか...!:thinking:）
  - ソフトウェアシステムは複雑であり、一見単純で自己完結的な単一ファイルへの変更でも、簡単に意図しない結果をもたらし、システムの正確性を損なうことがある。
  - trunk/masterブランチを安定させるために...
    - **開発者が互いに孤立して自分のブランチで作業する**。
    - これはまた、お互いの足を踏まないようにするためでもある。
    -  (trunk = 主要な開発ラインや基盤となるブランチを指す)
- しかし...
  - 各ブランチは互いに離れていく。
    - 1つのブランチをmainにマージするのは簡単。でも、**複数の長期ブランチをメインに統合するためには**、苦痛が伴うような大量の再作業が必要になる。
    - (Continuous Integrationは、長期ブランチをなるべく使わないように、**短期ブランチで継続的に統合していきましょう**、みたいな戦略のこと??:thinking:)
  - 長期ブランチを採用してるチームはどうしてる??
    - -> リリース前に複数のブランチを統合するために、コードフリーズ、もしくは統合(integration)&安定化(stabilization)フェーズに時間を使ってる。
    - 近代的なツールを使っても、このプロセスはまだ高価で予測不可能。
    - この問題は、**チームの規模が大きくなるにつれて、またブランチの寿命が長くなるにつれて、指数関数的に深刻になっていく**。
- そこで、継続的インテグレーションのプラクティス!
  - CIは、XP(エクストリームプログラミング)の原則に従う。
    - i.e. 「**if something is painful, we should do it more often, and bring the pain forward(何かが痛いときは、より頻繁に行い、痛みを前に出すべきだ)**」という原則。
- CIでは、**開発者は定期的に（少なくとも毎日）すべての作業をトランク（メインラインまたはマスターとも呼ばれる）に統合**する。(ええ！？CI難しそう...!:thinking:)
  -  自動テスト集合は、regressionが発生しないことを検証するために、マージ前とマージ後の両方で実行される。
  -  もし自動テストが失敗した場合、チームは自分達の作業を中断し、誰かが直ちに問題を修正する。
     -  (特にtrunk base開発とか、誰かが失敗したらチーム全員の作業が止まって全員で解決するのであれば、チームのバス係数は下がりそう...?:thinking:)
  -  -> これにより、**ソフトウェアが常に稼働状態にあること、また開発者ブランチがtrunkから大きく分岐しないこと**を確認する。

継続的インテグレーションの利点は非常に大きく、スループットの向上、システムの安定性、ソフトウェアの品質の向上につながることが研究によって示されている。しかしCIのプラクティスは、以下の**2つの理由から未だに議論の的になっている**:
  
- 理由1:
  - hoge
- 理由2:
   


### 基盤3: 継続的テストについて

- hogehoge
