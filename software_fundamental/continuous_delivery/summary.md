

## 継続的デリバリーの3つの基盤(foundations)について

継続的デリバリーは、以下の**3つの基盤**に基づいている。

- 1. 包括的な設定管理(comprehensive configuration management)
- 2. 継続的インテグレーション(continuous integration)
- 3. 継続的テスト(continuous testing)

### 基盤1: 包括的な設定管理(configuration management)について

- ソフトウェアを反復的にかつ信頼性高くリリースすることを保証する上で、**自動化は重要な役割を果たす**。
  - 自動化が果たす重要な役割の1つ
    - -> ビルド、デプロイ、退行テスト、インフラプロビジョニング(インフラのリソースを予測して提供すること?)のような、繰り返しの多い手作業プロセスを自動化すること。
    - -> これを実現するためには、**これらのプロセスを実行するために必要な全てのものをバージョン管理する必要がある**。
      - ex. ソースコード、テスト及びデプロイメントスクリプト、インフラおよびアプリケーションのconfig、依存する多くのライブラリやパッケージ, etc...
      - (version管理の重要さって、自動化するためなのか...!:thinking:)
    - また、ソフトウェア環境の現在と過去の状態を簡単に紹介できるようにしたい、というモチベーションもある。
      - (うん、これはversion管理のメリットとして想像しやすい:thinking:)
- configurationに関して、2つの最優先目標がある。
  - 1. **再現性(Reproducibility)**
    - 完全に自動化された方法で、どのような環境でもソフトウェアをビルド・デプロイ・テストでき、**同じconfigurationから再現される新しい環境は全て同じ結果を返す**ようにする必要がある。
  - 2. **追跡性(Traceability)**
    - 任意の環境を選んだときに、**その環境を作成するために使用された全ての依存関係のバージョンを迅速かつ正確に特定できる**ようにする必要がある。
    - また、任意の環境の過去のバージョンを比較し、**その間に何が変更されたかを特定できるようにする**必要がある。

- 達成したい上記の2つの能力(再現性、追跡性)は、開発組織に以下の重要な利点を与えてくれる:
  - 1. 迅速な災害復旧(disaster recovery)
  - 2. 高い監査可能性(Auditability)
  - 3. より高い品質(higher quality)
    - ソフトウェアのデリバリープロセスでは、開発・テスト・本番環境の準備を待つために、長い遅延が発生することがよくある。
    - これらを**バージョン管理から自動的に行うことができれば、変更影響に対するfeedbackをより迅速に得ることができ、ソフトウェアに品質を組み込むことができる**...!
  - 4. 容量管理(capacity management):
    - インフラの定義をバージョニング
  - 5. 欠陥への迅速な対応(quick response to defects)
    - システムに欠陥や脆弱性が見つかった時、できるだけ早くソフトウェアの新バージョンをリリースしたい。
      - 多くの組織では、緊急リリースのためのプロセスを持ってる。(ex. テストや監査の一部をバイパス、スキップする)
      - しかしこれは、safety-criticalなアプリケーションにおいて深刻なジレンマをもたらす。(テストスキップしちゃってるからじゃん...!:thinking:)
    - **理想的には、緊急リリースに通常のリリースプロセスが適用できるようになってることが望ましい! これが、包括的なconfiguration managementによって継続的デリバリーが実現したいこと...!**

- 全てのconfigをversion管理したいと言いつつも、完璧な再現性と追跡性を達成する事は不可能。
  - (version管理できない状態がどうしても存在するってことかな...!:thinking:)
  - **従って、configuration管理の重要なポイントは、投資に対して利益をより多く得るために、アーキテクチャ & 実行環境 & プロセスの単純化に取り組むこと...!!**
    - 投資(i.e. 費用) = 全てのconfig情報をversion管理するためのコスト
    - 利益(i.e. 効果) = 高い再現性と追跡性を達成することで得られるpositiveな効果

- 利益を達成するために努力する場合、我々は常に、**達成したい目標を測定可能な言葉で定義することから始めるべき**。
  - -> 目標に到達するための可能な経路のうち、最も良いものが何かを判断し、アプローチが高価すぎるか、時間がかかりすぎることがわかった場合には、**方向を変えたり、目標を再評価したりすることができる**。
    - (ABテストにおいてもmetricsを検討・feedbackを経て推敲し続けることが大事、みたいな話があったなぁ:thinking:)

#### FAQ

- どんなツールを使えば良い?
  - 多くの場合(全く適さないものを使わない限り)、道具の選択は成功の決定的な要因ではない。
- コンテナ/クラウド/仮想化技術は、このトピックにどのように影響する??
  - 最も重要なことは、**新たな進歩があるたびに、前述したような利益を、より簡単により安く達成できるようになる**ということ。
  - しかし、それ自体が特効薬というわけではない。
  - 我々が目標を達成するためには、引き続きバージョン管理とデプロイメント・パイプラインの包括的な使用の原則を適用する必要がある。

### 基盤2: 継続的インテグレーションについて

- **大前提、複数の開発者の仕事を組み合わせるのは難しい**。（これがCIのoriginなのか...!:thinking:）
  - ソフトウェアシステムは複雑であり、一見単純で自己完結的な単一ファイルへの変更でも、簡単に意図しない結果をもたらし、システムの正確性を損なうことがある。
  - trunk/masterブランチを安定させるために...
    - **開発者が互いに孤立して自分のブランチで作業する**。
    - これはまた、お互いの足を踏まないようにするためでもある。
    -  (trunk = 主要な開発ラインや基盤となるブランチを指す)
- しかし...
  - 各ブランチは互いに離れていく。
    - 1つのブランチをmainにマージするのは簡単。でも、**複数の長期ブランチをメインに統合するためには**、苦痛が伴うような大量の再作業が必要になる。
    - (Continuous Integrationは、長期ブランチをなるべく使わないように、**短期ブランチで継続的に統合していきましょう**、みたいな戦略のこと??:thinking:)
  - 長期ブランチを採用してるチームはどうしてる??
    - -> リリース前に複数のブランチを統合するために、コードフリーズ、もしくは統合(integration)&安定化(stabilization)フェーズに時間を使ってる。
    - 近代的なツールを使っても、このプロセスはまだ高価で予測不可能。
    - この問題は、**チームの規模が大きくなるにつれて、またブランチの寿命が長くなるにつれて、指数関数的に深刻になっていく**。
- そこで、継続的インテグレーションのプラクティス!
  - CIは、XP(エクストリームプログラミング)の原則に従う。
    - i.e. 「**if something is painful, we should do it more often, and bring the pain forward(何かが痛いときは、より頻繁に行い、痛みを前に出すべきだ)**」という原則。
- CIでは、**開発者は定期的に（少なくとも毎日）すべての作業をトランク（メインラインまたはマスターとも呼ばれる）に統合**する。(ええ！？CI難しそう...!:thinking:)
  -  自動テスト集合は、regressionが発生しないことを検証するために、マージ前とマージ後の両方で実行される。
  -  もし自動テストが失敗した場合、チームは自分達の作業を中断し、誰かが直ちに問題を修正する。
     -  (特にtrunk base開発とか、誰かが失敗したらチーム全員の作業が止まって全員で解決するのであれば、チームのバス係数は下がりそう...?:thinking:)
  -  -> これにより、**ソフトウェアが常に稼働状態にあること、また開発者ブランチがtrunkから大きく分岐しないこと**を確認する。

継続的インテグレーションの利点は非常に大きく、スループットの向上、システムの安定性、ソフトウェアの品質の向上につながることが研究によって示されている。しかし**CIの実践には以下の2つの障壁がある**。
  
- 理由1: CIは、開発者に次の要求を課す: 「**大きな機能変更などを、trunk/masterに頻繁に統合できるような、よりsmallな & よりincrementalなステップに分割せよ**」
  - 課題感: 
    - このやり方に不慣れな開発者にとっては、パラダイムシフトになる。また、大きな機能を「完成」させるのにもより時間がかかる...。
  - しかしそもそも、我々が最適化したいのは...!
    - X 開発者が自分の作業をブランチ上で「開発完了!」と宣言できる速度
    - ○ **変更をレビューし、統合し、テストし、デプロイできる速度**
      - -> これは、変更が小さく、自己完結しており、変更が所属するブランチが短命である場合に大幅に速度向上できる...!
      - (じゃあCIのプラクティスって、タスクを小さく分割して、短命ブランチでincrementalに開発していけってこと??:thinking:)
- 理由2: CIは、システムに次の要求を課す: 「**包括的な自動ユニットテストを高速に実行させよ**」
  - (CIと自動テストは同一の概念ではないけど、CIのプラクティスを実現するために自動テストが必要なのか...!:thinking:)
  - 自動テストは、ソフトウェアが期待通りに動作するという高い信頼レベルを提供するために**十分包括的であるべき**。かつ、**数分以内に実行されるべき**。
    - もし自動テストの実行に時間がかかると -> 開発者は頻繁に実行したくなくなる。
  - 自動テストのテストスイートの作成に関しては、TDDを通じて最もよく行われる。
    - CIにおけるTDDの最も重要な利点:
      - **モジュール化されてテストしやすいコードを書くことを保証できる -> 結果として、自動テストスイートのメンテナンスコストを削減できる...**!
      - (TDDによって、CIを実践するための包括的な自動テストを推進できる...!:thinking:)
    - ただTDDはまだ十分に普及してない。

- 上記2点の障壁にもかかわらず、CDの度を始めたい組織にとって、開発チームがCIの実践を支援することは最優先事項:
  - -> **CIは、迅速なフィードバックループを作成し、開発者が小ロットで作業することを保証することにより**、チームがソフトウェアに品質を組み込むことを可能にし、これにより、継続的なソフトウェア開発のコストを削減し、チームの生産性と彼らが生み出す作業の品質を向上させる。

#### FAQ

- 自分のチームが本当にCIを実践しているかどうかを知る方法は?
  - 3つの質問に答えられるか
    - 1. チーム内の全エンジニアが毎日 trunk/masterブランチにコードをpushしているか。
    - 2. すべてのコミットがユニットテストの実行のトリガーになっているか？ (なってる!:thinking:)
    - 3. ビルドが壊れたとき、通常10分以内に修正されるか?
  - 経験則的には、CIを実施していると思ってるチームのうち、実際にテストに合格できるのは20％以下。
    - CIツールを使わずにCIを行うことも可能であり、逆に、CIツールを使っているからといって、CIを行っているわけではないことに注意。
- トランクベースの開発とは、feature togglesを使うこと??
  - いいえ。
    - feature toggles は congigオプションを使って、ユーザから特定の機能を隠すこと。
  - feature togglesを使わずにtrunk-basedな開発を可能にするためには、**2つの重要なプラクティス**がある。
    - 1. APIに依存するUIを作成する前に、APIを構築すべき。
      - **API(それに対して実行される自動テストを含む)は、「ダーク」（つまり、それを呼び出すものがない状態）で作成され、本番環境にデプロイされることができ**、私たちはトランクでストーリーの実装に取り組むことができる。
    - 2. **大きな機能を小さなストーリー（1〜3日の作業）に分解し、それらが互いに反復的に、増分的に構築されるようにすることを目指すべき**。

<!-- 以下のコードレビューの話が良かった! -->

- Github-styleのデプロイについてどう思う??
  - ->ブランチが1日以上生存しない限り、GitHubの「フロー」プロセスは問題ない。
    - **もしあなたが機能をストーリーに分解し、インクリメンタルな開発を実践しているならOK**...!
  - また、コードレビューはプロセスの中で行うべき!
    - 理想的には、チェックインの準備ができたときに誰かを招待してペアプログラミングを行い、その場でコードをレビューする 
      - (うんうん...!ルールズオブプログラミングでも述べられてた...!:thinking:)
    - **コードレビューは継続的に行うのが最善であり、小ロットで作業することでそれが可能になる** 
      - (なるほど! ペアプロ的にレビューを行いやすくするためにもsmall batchesで作業する必要があるのか...!:thinking:)
    - 何日もの作業の結果であるページ数の多いdiffをレビューするのは誰も楽しめない。**なぜなら、大きな変更がシステム全体に与える影響を理解することができないから**。
      - (確かに、大きな変更をレビューするのは大変で、小さな変更をレビューするのは簡単だ!:thinking:)


### 基盤3: 継続的テストについて

- **CDの原則1つ目「Build quality in(品質を組み込む)」を達成するポイントは、変更の影響に関するフィードバックを迅速に得られるようにすること**。
  - (そのために、継続的テストが重要...!)
  - 従来は...
    - 手動テストが主流!　この種のテストは「開発完了」の後のフェーズで行われてた。
    - 開発完了後の手動テスト戦略の3つの欠点:
      - 1. 手動テストには長い時間とコストがかかる ->  ソフトウェアを頻繁にリリースできない。また、テスト対象のコードを書いて開発者にフィードバックを提供するのに数週間or数ヶ月かかる。
      - 2. regiressionテストのような反復作業を手作業で行うことは、人間には苦手で有名...!
        - 一連の変更の影響を検査で予測することは極めて困難であり、**手作業によるテストや検査は、そもそもあまり信頼できるものではない**...!!
      - 3. 最新のソフトウェアプロダクトは、システムの仕様がダイナミックに変化し得るので、テスト文書を最新の状態に保つことが困難。

上記の欠点から、「Build quality in(品質を組み込む)」を達成するためには、従来と異なるアプローチを採用する必要がある。
「我々の目標は、**デリバリープロセスの全体を通して、多くの異なるタイプのテスト(手動 & 自動)を継続的に実行させること**!」

以下の4象限図には、我々が実行させたいテストのタイプが示されている。

![](https://continuousdelivery.com/images/test-quadrant.png)

- 第一象限(左上): showcases usability testing, exploratory testing (manual)
  - 探索的なテスト、ユーザビリティテスト
- 第二象限(右上): functional testing (automated)
  - 機能要件に対するテスト
- 第三象限(左下): unit tests, component tests, system tests (automated)
  - 単体テスト、コンポーネントテスト、システムテスト
- 第四象限(右下): non-functional acceptance tests (ex. capacity, performance, security, etc...) (manual / automated)
  - 非機能要件に対するテスト

CIとテスト自動化が整理できたら、デプロイメントパイプライン(deployment pipeline)を作成する。(デプロイメントパイプラインは、CDにおける重要なパターン!)

- デプロイメントパイプラインパターンの各stepの流れ
  - 全てのcommitされた変更に対してビルドが実行され、packagingされ、ユニットテストなどの自動テストが実行され、数分の間に開発者にフィードバックを提供する。
  - 一連のテストに合格した後、より包括的な自動acceptanceテストが実行される。(pipelineの各stepが別れてるんだ...!)
  - 全ての自動テストに合格したパッケージは、usabilityテストや探索的テストができるtest環境にデプロイされる(手動テストのstep...!)
  - 最終的にOKと判断できればリリースされる。

以下は、簡単な直線状のデプロイメントパイプラインの例:

![](https://continuousdelivery.com/images/pipeline-sequence.png)

- デプロイメント・パイプラインでは、**すべての変更が実質的にリリース候補**(のpackage!)となる。
- デプロイメント・パイプラインのお仕事は、既知の問題をキャッチすること。
  - (これでcatchできない問題はincidentにつながるかもしれないが、その後の対応で既知の問題となり、次回以降はcatch可能になる...!:thinking:)
  - **もし既知の問題が検出されなければ、デプロイメントパイプラインを通過したパッケージをリリースしても全く問題ないと感じるべき**...!!
    - (うんうん、過度にビクビクする必要はなさそう。未知の問題はそもそもcatchできないので...!:thinking:)
    - デプロイメントパイプラインが成功しても、不安を感じてしまう場合、またはデプロイ後で不具合が発見された場合、テストの追加や更新など、パイプラインを改善する必要がある

デプロイメントパイプラインの導入に関して:

- まずはskeleton deployment pipeline (==スカスカのデプロイメントパイプライン??)を作成することから始める。
  - まずは最小限に、単一のユニットテスト、単一の受け入れテスト、探索的テスト環境を立ち上げる自動化デプロイメントスクリプトを作成し、それらを組み合わせる。
    - (曳光弾的な...!:thinking:)
  - そして、プロダクトの進化につれて、テストカバレッジを拡大し、デプロイメントパイプラインを拡張していく。

#### FAQ

継続的デリバリーとは、テスターを全員解雇すること??

- No!

すべてのテストを自動化すべき??

- No!

今すぐ手動テストをすべて中止し、自動化すべき??

- No!

誰が自動テストに責任を持つ??

- No!

# MLシステムと継続的デリバリーの話

参考: GCPさんのブログ [MLOps: Continuous delivery and automation pipelines in machine learning](https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning)

- MLOpsは、MLシステム開発（Dev）とMLシステム運用（Ops）の一体化を目指すMLエンジニアリングの文化と実践。
- 
