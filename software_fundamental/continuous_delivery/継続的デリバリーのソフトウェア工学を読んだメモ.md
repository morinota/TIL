## これは何?

- 書籍「継続的デリバリーのソフトウェア工学」を読んだメモです。

## 全体像

- 本書籍におけるソフトウェア工学の定義。
  - 「ソフトウェアの**現実的な問題に対する効率的、経済的な解**を見つけるための**経験的、科学的な**アプローチの応用」
- なんでソフトウェア開発に、工学的アプローチを取り入れることが重要なの??
  - **2つの理由**:
    - ソフトウェア開発が常に発見と学びの連続であること。
    - 「効率的」で「経済的」であることを目指すなら、**学びの能力は持続可能なものでないといけない**こと。
  - なので、**新しいことを学び考えを修正する能力を保ち続ける**必要があり、そのために**作ってるシステムの複雑さを管理**しないといけない。
    - 従って我々は、**学びのエキスパート & 複雑さ管理のエキスパート**になる必要がある!
- 学びのエキスパートであるために重要な**5つ**のテクニック:
  - 反復的な作業 (iteration)
  - フィードバック (feedback)
  - 漸進主義 (incrementalism)
  - 実験主義 (experimentation)
  - 経験主義 (empiricism)
- 複雑さ管理のエキスパートであるために必要な**5つ**のテクニック:
  - モジュラー性 (modularity)
  - 凝集度 (一体性, cohesion)
  - 関心の分離 (separation of concerns)
  - 抽象化 (abstraction)
  - 疎結合 (loose coupling)
- 10個のテクニックは全部知ってるよ、って片付けてしまうのは簡単だが...
  - **重要なのは、これらを有機的に結びつけて、ソフトウェア開発における一貫性のあるアプローチの中に位置付けて(i.e. 意味付け...!!:thinking:)、これらの価値を最大限に引き出せること**...!!
- 本書は、上述した10個のテクニックを何のためにどのように使うべきかの戦略を論じてる。効果的な戦略を展開するために役立つ実践的な**5つの要素**:
  - テスト可能性 (testability)
  - デプロイ可能性 (deployability)
  - スピード (speed)
  - 変数の管理 (controlling the variables)
  - 継続的デリバリー (continuous delivery)

## 学びのエキスパートのメモ

## 複雑さ管理のエキスパートのメモ

### 1つ目: モジュラー性

- 何それ?? = 「システムのコンポーネントが分割、再結合されている度合い」
- なんで重要なんだっけ?? 意味付け!
  - 巨大システムの全てを人間は理解できない。理解できないと学んだ時にコードを変更するのが大変になる。なので**学びの能力を持続的に持ち続けるため**に、**システムを小さく理解しやすい部品に分割**する必要がある!
    - 「小さく理解しやすい部品」 = **システムの他の部分で何が行われてるかをあまりに気にせずに、開発に集中**できるような部品！
  - モジュラー性の本質: システムやコードのある部分を変更したときに、それが他の部品に与える影響を心配しなくて済むこと!
    - **逆にモジュラー性が低いと、新しいアイデアを追加してソフトウェアを発展させ続ける力が急速に低下していく...!!**
  - モジュラー性は**どの粒度の設計でも常に重要**! 様々な粒度で該当するフラクタルなテクニックなので!
- 著者のtips: commitステージで、30行を超えるメソッドや、引数が5個を超えるメソッドシグネチャを検出し弾き出すようにしてるらしい。
  - (これいいな、Pythonでもmypyなどの静的解析でやってみようかな...!!:thinking:)
  - 注意点: ここでの閾値は重要ではない。重要なのは、**設計で手を抜かないようにするためにはこのような目安を設けるべき**だということ!
- 著者はTDDが好き! 「TDDは魔法ではないが、設計に関する**エンジニアの能力増幅器**だ！」
  - 前提: モジュラーなコードを設計することはめちゃ難しい。一生かかっても完璧にはできないかも。
  - **テストは、設計の品質について早期に正確なフィードバックを与えてくれる!**
  - テスト可能性(testability, テストしやすさ)を意識してアプリケーションコードを設計することで、各エンジニアができる範囲のモジュラーな設計を実現できる...!!
- 「サービス」と「モジュラー性」の関連
  - サービスってどんな概念? = 曖昧ではある。実用的な考えでは、ユーザに何らかの「サービス」を提供し、その「サービス」をどのように提供するかの詳細は隠蔽してる。
    - (なんかモジュラー性っぽいし、抽象化(情報隠蔽)っぽい...!:thinking:)
  - サービスの重要で素晴らしい考え方: **システム設計の中でシーム(継ぎ目)を見つけて、システムの他の部分は、そのシームの向こう側を知る必要がなく、知るべきでもない！** 
    - (これはまさにモジュラー性にも通じるよね...!:thinking:)
    - ソフトウェア開発における「サービス」には、**「境界」的なニュアンス**もある...!:thinking:
- モジュラー性の高いコードを書くように誘導するには、「依存性注入」は有効なテクニック!
  - 依存性(i.e. システムが依存するコード)はシステムに注入することで、よりテスト可能性が高まる計測点(i.e. ノギス)を得られる!
    - テスト可能性が高まる → モジュラー性の高いコード → エンジニアが読みやすく学びの能力を持続的に持ち続けることができるコード!
  - 依存性注入は、**システムのサーフィスエリアを広げるテクニック**と言える。

### 2つ目: 凝集度

- 何それ?? = (コンピュータ科学における)凝集度は、モジュール内の要素が一体的である度合い。
  - 片方を変更したらもう片方も変更しないといけない、みたいな関係性がある概念達を、近くにまとめられているか、みたいな...!
  - **凝集度が大きな意味を持つのは、主としてモジュラー性と同時に考えた時！**
    - 凝集度とモジュラー性のバランスを取るために重要な要素が、後述される関心の分離!
- モジュラー性と凝集度の関係
  - ケントベックの言葉: 「関係のないものを引き離し、関係のあるものを近くに集めよ」
  - 学びのエキスパートであり続けるために、我々エンジニアは、**より小さく、より理解しやすく、よりテストしやすい部品からシステムを構築できなきゃ...!!**
    - -> 「関係のないものを引き離す」のと同じくらい「関係のあるものを近くに集める」ことも重要!! (特に後者が凝集度っぽい話...??:thinking:)
  - **モジュラー性が真に価値を発揮するには、モジュール内の凝集度が高い必要がある...!!**
- テスト可能性は、モジュラー性、高凝集性、関心の分離、抽象化(情報隠蔽)など、品質の高いコードだと思われる性質を強力に後押しする! (モジュラー性でも言ってた！)
- でも本書籍は答えは教えられない! 正解を探すのはあなた!
  - ここで提示しているのは、**答えがまだわからないうちから安全に前に進み続けられるためのアイデアとテクニックのコレクション**!
  - 防御的(漸進的)アプローチと言えるかも!
    - 目的: **いつまでも選択の自由を持ち続けられる**こと!
      - (これが複雑さ管理の大きなメリットの一つ!)
- 凝集度とカップリングの関係:
  - 前提: 凝集度もカップリングも程度の話。白か黒かではない。
  - カップリングはある程度は凝集度のコスト:
    - システムの中で凝集度の高い2つの部分は、他の部分よりもも密結合になってるよね!
- 凝集度の高いコードを後押しする、という点でもTDDは有効!!
  - TDDにより、外部API/インターフェース(どんな形であれ)の設計に集中できる! -> 凝集度の高いコードを設計できる!

凝集度が本当にひどいコード例。

```python
class ReallyBadCohesion:
    def load_and_process_and_store(self)->None:
        # load処理の実装...

        # process処理の実装...

        # store処理の実装...
```

凝集度が少しましになったコード例。でも悪い。

```python
class BadCohesion:
    def load_and_process_and_store(self)->None:
        self._load()
        self._process()
        self._store()

    def _load(self)->None:
        # load処理の実装...

    def _process(self)->None:
        # process処理の実装...

    def _store(self)->None:
        # store処理の実装...
```

まあまあ凝集性が高くなったかなっていうコード例。

```python

class LoaderA:
    def load(self)->None:
        # load処理の実装...
class ProcessorA:
    def process(self)->None:
        # process処理の実装...
class StorerA:
    def store(self)->None:
        # store処理の実装...

class GoodCohesion:
    def __init__(self, loader:LoaderA, processor:ProcessorA, storer:StorerA)->None:
        self._loader = loader
        self._processor = processor
        self._storer = storer

    def load_and_process_and_store(self)->None:
        self._loader.load()
        self._processor.process()
        self._storer.store()
```





## いい感じの戦略を展開するためのツール達
