# 参考

- https://qiita.com/drken/items/fd4e5e3630d0f5859067#%E7%AC%AC-7-%E5%95%8F--abc-085-b---kagami-mochi-200-%E7%82%B9

# 問題概要
N 個の整数 d[0],d[1],…,d[N−1] が与えられます。
この中に何種類の異なる値があるでしょうか？
(原問題文をかなり意訳していますが、題意はこういうことです)

## 制約
- 1≤N≤100
- 1≤d[i]≤100
- 入力値はすべて整数

## 数値例
N=4
Q=3
d=(8,10,8,6)
答え: 33
6, 8, 10 の 3 種類です。

# キーポイント
- 集計処理
- バケット法
- 連想配列

# 解法
これもまた ABC の B 問題や C 問題で超頻出の集計処理です。
B 問題ではバケット法といって、配列 num を用意しておいて、

num[i] := 値 i が何個あるか

とすれば十分なケースがほとんどです。C 問題ではこの i の値が大きくなるため単純な配列では通用しなくなる出題が登場します (i が大きいと単純な配列でダメなのはメモリが足りないためです、その場合は連想配列と呼ばれるものを用います、C++ では std::map 、Python では dictionary が使えます)。

この問題についても、std::set や std::map を用いて解くこともできます。

# コメント

今後は単なる集計処理の枠組みを超えて、バケット法が暗黙に使える場面は劇的に増えていきます。ビットを用いた複数フラグ管理もバケット法の一種と言えますし、バケットを Binary Indexed Tree に乗せて k 番目に小さい値を求める処理を高速に実行する話題があります (Binary Indexed Tree は高級な話題なので現時点では無理に勉強しなくても大丈夫です)。

# 類題

- ABC 071 B - Not Found　(アルファベットは結局 0 〜 25 という値と同じことです)
- ABC 061 B - Counting Roads　(ちょっとした応用問題です)
- ABC 047 B - Snuke's Coloring 2 (ABC Edit)　(二次元配列を用意します)
- ABC 091 B Two Colors Card Game　(std::map が使えると楽です)
- ABC 081 C - Not so Diverse　(C 問題ですが十分挑めます、バケット法とソートの複合問題です)