# 参考

- https://qiita.com/drken/items/fd4e5e3630d0f5859067#%E7%AC%AC-9-%E5%95%8F--abc-049-c---daydream-300-%E7%82%B9

# 【問題概要】

英小文字からなる文字列 Sが与えられます。
T が空文字列である状態から始めて、以下の操作を好きな回数繰り返すことで S=T とすることができるか判定してください。

- T の末尾に "dream", "dreamer", "erase", "eraser" のいずれかを追加する。

# キーポイント

一見手がかりが掴めないような問題でありながら、端っこから順に考えると芋づる式に全体が決まって行くタイプの問題は ABC の C 問題では頻出です。これは Greedy アルゴリズムの一種であると言うことができます。

というわけでまずは文字列 SS を先頭から順に "dream", "dreamer", "erase", "eraser" に分解していくことを考えてみましょう。しかし例えば上の例題の数値例にあるように、"dreameraser" を先頭から順に 5 文字 dream まで読み進めたときに、そこで切っていいのかそれとも次の er まで進んで dreamer で切るべきなのかを判断することは容易ではなさそうです。

しかしなんと、SS を後ろから順に "dream", "dreamer", "erase", "eraser" に分解しようと思うと状況は一変します！

前から読むと "dream" が "dreamer" に完全に被っていました (こういう関係を **prefix **と呼びます)。しかし後ろから考えると、"dream", "dreamer", "erase", "eraser" のうちのどの 2 つをとってもそのような関係にはありません。したがって、文字列Sが与えられた時に、どこで切っていけばいいのかは後ろから順番に芋づる式に決まっていく。

# コメント

「後ろから解く」という発想は少し難しいかもしれませんが、何気によく出て来る考え方です。ただし今回後ろから芋づる式に解くことができたのはたまたまだと言えます。実際、前から解いても後ろから解いても「どこで切ったらいいかわからない」という問題設定を考えることもできます。そのような状況で有力な手法として動的計画法 (DP) と呼ばれる手法があります。この例題も DP によって前から解くことも可能です。なお DP までしなくても、前から深さ優先探索 (DFS) や幅優先探索 (BFS)、少し先まで見る Greedy などの解法によってゴリ押すこともできます。これらの別解法については、@259_Momone さんの以下の記事を参考にしていただければと思います:

なお、ある文字列が他の文字列の prefix になっているかどうかというのは、文字列の問題において極めて重要な概念です。今後 Suffix Array などを学ぶときに思い出すとよいと思います。

# 類題

- AGC 013 A - Sorted Arrays　(数列の端から順にできるだけ長い列を切り出す Greedy です) 
- AGC 011 A - Airport Bus　(同様に小さい方から順に切り出して行く Greedy です)
- ABC 059 C - Sequence　(最初の a[0] を正か負かを決めると芋づる式に決まります)
- ABC 072 C - Together　(X を決めると Greedy にすべて決まります)
