# 参考

- https://qiita.com/drken/items/fd4e5e3630d0f5859067#%E7%AC%AC-6-%E5%95%8F--abc-088-b---card-game-for-two-200-%E7%82%B9

# 問題概要
N 枚のカードがあり、i 枚目のカードには a_iという数が書かれています。
Alice と Bob はこれらのカードを使ってゲームを行います。ゲームでは 2 人が交互に 1 枚ずつカードを取っていきます。Alice が先にカードを取ります。
2 人がすべてのカードを取ったときゲームは終了し、取ったカードの数の合計がその人の得点になります。2 人とも自分の得点を最大化するように最適戦略をとったとき、Alice は Bob より何点多くの得点を獲得できるかを求めてください。

## 制約
N は 1 以上 100 以下の整数
a_i は 1 以上 100 以下の整数

## 数値例
N=3, a=(2,7,4), 答え: 55

以下が最適：
- 1 ターン目: Alice が 7 を取る
- 2 ターン目: Bob が 4 を取る
- 3 ターン目: Alice が 2 を取る

Alice は 7 + 2 = 9 点、Bob は 4 点を獲得するので、その差は 9 - 4 = 5 点です。
# キーポイント

- ソート
- Greedy

# 解法
来ました！ソートです！
ついに競プロらしさが徐々に出て着ます。ソートはアルゴリズム学習者が最初に詳しく学ぶものですが、競プロ的には std::sort() を使いこなせるようになればほとんどの場面で十分です。C++ では std::sort() ですが、他の多くの言語でもソート処理はサポートされています。

さて、この問題は一見とっつきにくいですが、最適戦略はとても簡単です。2 人とも残ってるカードの中から最も大きい値を取ればよいです。具体的には、配列 a を大きい順にソートして、前から順に 2 人が交互に取って行けばよいです。

下のソースコードの注意点として、sort(a, a+N, greater<int>()) の greater<int>() について解説します。これをなくして sort(a, a+N) とすると配列 a[0:N] は値が小さい順にソートされてしまいます。今回はどちらかと言うと大きい順にソートしたいので、それを指定するために greater<int>() をつけています (小さい順にソートしておいて後ろから交互に取る実装方法もあります)。

# コメント
ソートを自在に使いこなせるようになると、解ける問題の幅が大きく拡がります。

# 類題

- ABC 067 B - Snake Toy　(ソートです)
- ABC 042 B - Iroha Loves Strings　(ソートする対象が文字列になります)
- AGC 027 A - Candy Distribution Again　(ソートして小さい順に配って行きます)
- AGC 012 A - AtCoder Group Contest　(少し難しめのソート問題です、是非挑戦してみましょう)
