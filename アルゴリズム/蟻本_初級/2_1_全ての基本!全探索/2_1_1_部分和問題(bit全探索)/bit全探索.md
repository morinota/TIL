- https://qiita.com/drken/items/e77685614f3c6bf86f44


# bit全探索

## bit全探索とは?

- 「n 個の選択肢それぞれに Yes or No の二択があるが、その部分集合（選択できるパターン）の全てを網羅的にチェックしたい」といった場合に使える。
- Yes or No の二択が n 箇所あるので、パターン数は$2^n$になる。
- この選択肢の1つ1つを2進数の bit に見立ててシフト演算でチェックを行うことから「bit 全探索」とも呼ばれるが、やっている事は単なる全探索。

## 例題1

> みかん（100円）りんご（200円）ぶどう（300円）がそれぞれ1つずつ果物屋さんにありました。財布の中には300円ありますが、考え得るすべての買い物パターンを列挙しなさい。

全ての買い物パターンで合計金額を計算し、その中から300円以下で済んだものを列挙すればよさそう...
全部で $2^3 = 8$ パターンとなりますので、基本的にはこれで for ループを回してチェックを行う。
（「何も買わない」「み」「り」「ぶ」「み＋り」「み＋ぶ」「り＋ぶ」「み＋り＋ぶ」の8通り）

```python
money = 300
item = (("みかん", 100), ("りんご", 200), ("ぶどう", 300))
n = len(item)
for i in range(2 ** n):
    # ここで必要なチェックを行う
```

ここで各アイテムを買う / 買わないを「2 進数のそれぞれの桁が 0 であるのか 1 であるのか（左から順に、みかん、りんご、ぶどう）」で表現してみる。
i = 0 から i = 7 までの間にきちんと全チェックできそうなことが分かる。

では、たとえば i = 5 の時にそれが「みかん＋ぶどう」であることをどうやって判別すればいいのか？
「**2 進数表記のそれぞれの桁が 0 であるか 1 であるか」がどのアイテムを購入したかを表すフラグ**になっていますのでこれをチェックすれば良さそう。

2 進数表記した場合の下から数えて n 桁目（一番下の桁を 0 とします）が 1 であるかどうかをチェックするためのコードは、`(i >> n) & 1`。
これは「i を n 回右にシフトして 1 と論理積を取る（最下位の桁が 1 であるかどうかチェックする）」ということになる。

```python
>>> i = 5
>>> bin(i)
'0b101'  # 5 を 2 進数で表記すると 101
>>> bin(i >> 2)
'0b1'  # 5 を 2 回右にシフトすると 001
>>> print((i >> 2) & 1)
1  # 5 を 2 回右にシフトしたものと 1 の論理積は 1 (=True)
```

下から 0 桁目が 1 であればぶどう入り、下から 1 桁目が 1 であればりんご入り、下から 2 桁目が 2 であればみかん入りということになるので、最初のコードに上記のチェック方法を加えてみる。

```python
money = 300
item = (("みかん", 100), ("りんご", 200), ("ぶどう", 300))
n = len(item)
for i in range(2 ** n):
    bag = []
    print("pattern {}: ".format(i), end="")
    for j in range(n):  # このループが一番のポイント
        if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
            bag.append(item[j][0])  # フラグが立っていたら bag に果物を詰める
    print(bag)
```

出力結果は以下の通りで、どうやらうまくピックアップできた様子。

```python
pattern 0: []
pattern 1: ['みかん']
pattern 2: ['りんご']
pattern 3: ['みかん', 'りんご']
pattern 4: ['ぶどう']
pattern 5: ['みかん', 'ぶどう']
pattern 6: ['りんご', 'ぶどう']
pattern 7: ['みかん', 'りんご', 'ぶどう']
```

解答例

```python
money = 300
item = (("みかん", 100), ("りんご", 200), ("ぶどう", 300))
n = len(item)
for i in range(2 ** n):
    bag = []
    total = 0
    for j in range(n):  # このループが一番のポイント
        if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
            bag.append(item[j][0])  # フラグが立っていたら bag に果物を詰める
            total += item[j][1]  # 買い物累計額にも加算
    if (total <= money):
        print(total, bag)
```

## 例題2 ABC 079 C Train Ticket

- https://atcoder.jp/contests/abc079/tasks/abc079_c

小学校時代にあった算数クイズ。0290 といった数字同士の隙間に + か − を入れて特定の答え（今回の場合は 77）を導き出すアレ。0−2+9+0=7

数字同士のすき間にためしに + か − を片っ端から入れてみて答えが導き出せるパターンを書き出せばよさそう。

「**数字同士のすき間の個数分**、**二択（+ or −）が存在**し、**それらを全探索**したい」ので bit全探索が使える！


## evalが便利!

## 計算量(loop 数)について
選択肢が n 個ある場合のループの回数は$n \times 2^n$回となる。
$2^n$アルゴリズムは比較的すぐに計算量爆発が起こるので、選択肢の制約条件には十分注意。