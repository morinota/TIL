# 参考

- 典型的な DP (動的計画法) のパターンを整理 Part 1 ～ ナップサック DP 編 ～
  - https://qiita.com/drken/items/a5e6fe22863b7992efdb

# はじめに --- DP は役に立つ

DP を学び立ての方がよく抱く悩みとして「バリエーションが多すぎて混乱するし、統一的なフレームワークがほしい」というのがあるらしい。確かに DP のバリエーションは非常に多岐にわたるのですが、そのほとんどが以下の 3 つのフレームワークで説明できるらしい...。

- ナップサックDP
- 区間DP
- bit DP

今回はこのうちのナップサック DP について、とにかく「習うより慣れろ」の精神で、これらのパターンの例題を幾つか解くことで、自然に典型的な DP の世界を俯瞰することを目指す。

# ナップサック DPとは??

## 問題1 最大和問題

**$n$ 個の整数 $a[0], a[1], \dots, a[n-1]$ が与えられる。これらの整数から何個かの整数を選んで総和をとったときの、総和の最大値を求めよ。また、何も選ばない場合の総和は 0 であるものとする。**

**【制約】**
**・$1 \le n \le 10000$**
**・$-1000 \le a[i] \le 1000$**

**【数値例】**
**1)**
**　$n = 3$**
**　$a = (7, -6, 9)$**
**　答え: 16 (7 と 9 を選べばよいです)**

**2)**
**　$n$ = 2**
**　$a = (-9, -16)$**
**　答え: 0 (何も選ばないのがよいです)**

既にお気づきの方が多いと思いますが、これは DP を使うまでもなく「正の値を全部足す」だけでよいです。しかし、この問題を敢えて DP で書いてみることで DP に慣れようという企画です。

### 解法

<DP遷移式>

$$
dp[i+1] = max(dp[i], dp[i]+a[i])
$$

数学で言うところの漸化式と一緒ですね。遷移していくためには、初期値が必要です。初期値は、

$$
dp[0] = 0 \text{何も選んでいない初期状態}
$$

Pythonで書くとたぶんこんな感じ：

```python
n = int(input())
a = [0] * 10010  # 最大10000個ですが、少しだけ多めにとります

dp = [0] * 10010  # DP テーブル

dp[0] = 0
for i in range(0, n, 1):
    dp[i + 1] = max(dp[i], dp[i] + a[i])

print(dp[n])
```

さて、いよいよ次からナップサック問題を考えてみる！

# ナップサック問題

ナップサック問題の登場までが長くなってしまったが、本来 DP 以外で簡単に解ける問題を敢えて DP で解いたのは、ナップサック問題に対する DP はこれよりも一段難易度が上がるから。

## 問題2 ナップサック問題

- n 個の品物があり、i 番目の品物のそれぞれ重さと価値が weight[i],value[i]となっている (i=0,1,...,n−1)。
- これらの品物から重さの総和がWを超えないように選んだときの、価値の総和の最大値を求めよ。
- 制約

  - 1<=n <= 100
  - $weight[i], value[i]$は整数
  - $1<=weight[i], value[i]<= 1000$
  - $1 <= W <= 10000$

- さっきの問題が「価値」だけだったのに対し、「重さ」が加わった感じ。
- 基本的に、重さに対する価値の比率 が大きいものを選んでいきたい訳だが、単に「$value/weight$が大きい順にソートして、重さがWを超えないギリギリまで詰める」という方針では最適解になるとは限らない。

### 解法

さっきと同じようにやります。しかし、完全にさっきと同じように

「$dp[i+1]:=$ i番目までの品物の中から重さが W を超えないように選んだときの、価値の総和の最大値」

としてしまうと詰まってしまう。
**dp[i+1]を考えるときに、dp[i]に対して品物(weight[i], value[i])を加えるか否かを考えるが、加えた時に重さがWを超えてしまうのかどうかが分からない**という問題が起こる。
dp[i]に対して、「今重さがどうなっているか」という情報が必要なのである。
そこで少し修正して、以下のようにする。

dp[i+1][w] := i番目までの品物の中から重さが$w$を超えないように選んだ時の、価値の総和の最大値

そして先ほどは、dp[i]の値が求まっている事を前提にしてdp[i+1]の値を考えたが、今回は$dp[i][w](w=0,1,...,W)$の値が求まっている事を前提にして、$dp[i+1][w](w=0,1,...,W)$の値を考えてみる。

$dp[i+1][w]$の値を求めるには、以下のうち大きい方を取る：

- 品物iを選ぶ場合($w>= weight[i]$の場合のみ)

  $$
  dp[i+1][w] = dp[i][w - weight[i]] + value[i]
  $$

- 品物iを選ばない場合
  $$
  dp[i+1][w] = dp[i][w]
  $$

まとめると以下のようになる：

DP漸化式
$$
dp[i+1][W] = \\
\left\{
\begin{array}{ll}
max(dp[i][w - weight[i]] + value[i], dp[i][w]) & (w\geq weight[i])\\
dp[i][w] & (w < weight[i])
\end{array}
\right.
$$

DP初期条件
$$
dp[0][w] = 0 (w = 0,1,\cdots ,W)
$$

「問題1: 最大和問題」に比べると、dp テーブルの添字が 1 個から 2 個に増えた分、少しだけ難易度が上がった。
実際に DP を設計するときに、「これだけじゃ情報が足りない -> 添字を付け足す」というのは非常によく行うらしい.

```python
# 入力
n, W = map(int, input().split())
weight, value = [0] * 110, [0] * 110

# DPテーブル
dp = [[0] * 10010] * 110

# DP初期条件: dp[0][w] = 0
for w in range(0,W+1, 1):
    dp[0][w] = 0

# DPループ
for i in range(0,n,1):
    for w in range(0,W+1, 1):
        if w >= weight[i]:
            dp[i+1][w] = max(
                dp[i][w-weight[i]] + value[i], dp[i][w]
                )
        else:
            dp[i+1][w] = dp[i][w]

print(dp[n][W])
```

なお、このナップサック問題に対するDPについて、実際にテーブル致が更新されていく様子は下図。(weight, value = (2,3),(1,2),(3,6),(2,1),(1,3),(5,85)の場合)
![](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F182963%2Ffcd3c29a-9f3e-7984-3549-21fa113fab26.jpeg?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=377698e9e303a3e2b60e22c2d6b3c6fa)