# 参考

- https://enakai00.hatenablog.com/entry/2021/07/14/134445

# はじめにどうやら...

上記の例題は...

- 愚直にDPを実装すると実行時間制限（場合によっては、メモリー容量制限）に引っかかる
- 、愚直なDPの中身をよくよく理解した上で、どこで時間がかかっているのかを理解して、実行時間を削減する工夫をうまく入れないといけない

らしい...。

# DP(動的計画法, dynamic programming)の基本的な考え方

- 「N個の〇〇に対して・・・・」という問題が与えられた時に、いきなり大きな N で考えるのはつらい
  - なのでまずは、一番簡単な N=1 の場合（どれか1個のデータをピックアップした場合）の答えを速攻で求めてしまう。
- で、**その答えが分かった前提**で、N=2 の場合（正確には、N=1 の場合にピックアップしたデータに対して、さらにもう1つのデータをピックアップして加えた場合）の答えを求める。
  - この時、**N=1 の結果をどのように再利用するか**をよく考える。
- さらに次は、N=1 と N=2 の答えが分かった前提で、3個目のデータを加えた場合の答えを求める。
- ということを繰り返していると、一般に、「1 〜 n-1 個のデータに対する答え」を利用して、さらにもう1つのデータを加えた「n 個のデータに対する答え」を導く方法が思いつくかも知れない。
- これが思いついてしまえば、後は、この処理をループで繰り返せば、N がどれほど大きくても、N 回のループ処理で必ず回答に辿り着くことができる。

テンプレート的なコードは以下。（小文字の n と大文字の N は別の変数なので注意してください。）

```python
dp[1] = xxxx # 1個の場合の答えを自力で考えて入力する

for n in range(2, N+1):
  dp[n] = transition(dp, n) # dp[1] ... dp[n-1] の情報を使って n 個の場合の答え dp[n] を計算する関数

print(dp[N])
```

一般に、dp[1] ... dp[n-1] を使って dp[n] を求める計算を**遷移処理**と呼んだりもする。

## 遷移処理の例題(N個の整数A_1~A_Nの和)

はい。DPを使うのはおこがましい様な例だが、上記のテンプレートになれる練習だと思ってください。答えはこちら。

```python
N = 6
A = [None, 3, 1, 4, 1, 5, 9]
dp = [None] + [0]*N

dp[1] = A[1] # N=1 の場合

for n in range(2, N+1): # N=2以降の処理
  dp[n] = dp[n-1] + A[n] # 遷移処理

print(dp[N])
```

なお、さきほどのテンプレートでは、遷移処理を transition(dp, n) という関数で表現しましたが、この**関数の中でつかってよい情報には制限がある**。(重要！)

それは、**dp[1] ... dp[n-1]、および、A[n] **です。

dp[1] ... dp[n-1] を求める際にかつて利用した** A[1] ... A[n-1] は、この段階では、もはや使うことはできない**！

## 遷移処理の例題(もうちょっと一般的なDP)

上記の例題だと、DPって、ほんとーに簡単な考え方のように思えますが（実際、考え方自体は簡単なんですが）、もう少し一般的には、特定の n について、1つの答え dp[n] を求めるのではなく、**条件を変えた複数の答え dp[n][m] を求める必要がある**。（添字 m が条件の違いを表す。）

冒頭に示した有名なナップサック問題が、まさにこれに当たる。
重さの合計が W 以下になる条件で荷物をピックアップした時に、価値が最大になる組み合わせを見つけて、その時の価値の値を答える必要があります。
（この問題の場合は、組み合わせそのものは答える必要がなくて、価値の最大値だけを答えればOKです。ここがちょっとしたポイントになる。）

で、テンプレートにしたがって考えると、まずは、1個目の荷物（価値 v[1]、重さ w[1]）だけが与えられたデータだと仮定して問題を解く。

- w[1] <= W なら dp[1] = v[1]
- w[1] > W なら dp[1] = 0

コードで実装するならこんな感じ！

```python
if w[1] <= W:
  dp[1] = v[1]
else:
  dp[1] = 0
```

なのですが・・・・

実は、この答え dp[1] だけが分かっていても、次のケース、つまり、2個目の荷物を加えて、

- 1個目の荷物：価値 v[1]、重さ w[1]
- 2個目の荷物：価値 v[2]、重さ w[2]

だけが与えられたデータと仮定した問題を解くための十分な情報にはならない。
先ほど、説明したように、この段階で使ってよい情報は、

- **dp[1]、v[2]、w[2]**

だけである点に注意。
問題の想定としては、1個目と2個目の荷物がある場合の問題を解いているのですが、DP の手続きとしては、（dp[1] の他には）2個目の荷物の情報しか使えない。

そうすると、何が困るかというと、2個目の荷物を入れるべきかを判断する際に、**1個目の荷物が入っていたとして、ナップサックの残り容量（W-w[1]）が w[2] 以上あるか**を考慮する必要がありますが、dp[1] にはそのような情報は含まれていない。

ここで登場するのが、「**条件を変えた複数の答え dp[n][m] を求める**」という発想。

いまの場合、何が条件かというと、ナップサックの容量 W です。**本来解きたいのは、ある特定の W に対する問題なのですが**、**DP を考える場合は、「さまざまな W について、全部の場合を解いてしまう」ことを考える**。

「全部の場合」というと、範囲が無限にあってこまってしまいますが、今の場合は、（荷物の重さはすべて自然数という前提で）ナップサックの容量が0, 1, 2, ..., WのW＋1種類のケースを考えればＯＫ！

なぜこれでOKと分かるの？？？？　と思う方もいるはずですが、実は、ここがDPの難しい所で、どういう条件を網羅すればよいかというのは、一般論は無くて、与えられた問題ごとに試行錯誤で見つけ出すしかない...！で、だいたいの場合は、「おまえそれ良く思いついたなぁ。。。。」的な「とんち問題」っぽいものになってるんですよね。。。。まぁ、ここは、DPとはそういうもんだと割り切って、沢山の典型例を見て、感覚をつかんでいくしかない...!

で、今の場合は、こんな感じ。まず、1個目の荷物だけが与えられた場合の答えを改めて求めると、こんな感じのループになる。

```python
for w0 in range(0, W+1):
  if w[1] <= w0:
    dp[1][w0] = v[1]
  else:
    dp[1][w0] = 0
```

ナップサックの容量w_0についてのループで、w_0=0, 1, ..., Wの全ての場合の答えを個別に dp[1][w0] に格納している！

それでは、この情報を用いて、

- 2個目の荷物：価値 v[2]、重さ w[2]

を追加した場合の答え dp[2][w0] について考えてみる。

いま、求めるべきものは、「価値の合計が最大になる入れ方（その場合の価値の合計値）」なのだが、論理的に考えて、「2個目の荷物を入れない場合」か「2個目の荷物を入れる場合」のどちらかがその答えになるはず。そこで、

- 2個目を入れない前提で達成できる最大価値　----- (1)
- 2個目を入れる前提で達成できる最大価値　----- (2)

のそれぞれを個別に計算して、得られる最大価値の大きな方が、本当の意味での正解、ということになる。

で、(1) の場合の答えを考えるわけですが・・・・そう！これはもう分かっている。2個目の荷物は無視して、1個目の荷物だけで価値を最大にする方法を考えればよい。先に計算した dp[1][w0] がその答えになります。**1個目の荷物の具体的な情報（w[1]、v[1]）は使わずに、d[1] の情報だけで答えが得られた**。
これこそが「**DPの心**」！

ではでは、(2) の場合はどうなるのか？

まず、w[2] > w0 の場合は、（1個目の荷物を入れたかどうかに関係なく）そもそも2個目の荷物を入れることは不可能なので、お約束により最大価値は 0 になる。一方、w[2] <= w0 の場合は・・・・。うーん。1個目の荷物を入れたかどうかで、結果がかわるよなぁ。。。うーん。。。。

・・・・通常の思考では、こうなるのですが、ここで、ちょっとだけ**発想を逆転**します。

今はとにかく、2個目の荷物を入れるという大前提で考えているわけなので、まず、からっぽのナップサックを用意して、先に2個目の荷物を入れてしまう！すると残りの容量は w0-w[2] になるので、この（ちょっとだけ容量が小さくなった）ナップサックに、1個目の荷物を入れるかどうかを判断すればよい。

**例によって、1個目の荷物の具体的な重さ w[1] の情報は使えないので、1個目の荷物が入るかどうかわからないのですが、そこは心配ない**。**いま欲しい情報は、「1個目の荷物だけ与えられた状況で、容量 w0-w[2] のナップサックに対して、最大価値を実現する入れ方」**である。
そう！これはもう分かっている！
先に計算した dp[1][w0-w[2]] がその答え！

というわけで、先に入れた2個目の荷物の価値 v[2] とあわせて、「dp[1][w0-w[2]] + v[2]」が (2) の答えになる。

というわけで (1) (2) のそれぞれがわかったので、比較して大きな方を dp[2][w_0] の答えに採用することができる。コードにまとめるとこんな感じ。

```python
for w0 in range(0, W+1):
  case1 = dp[1][w0]
  if w[2] > w0:
    case2 = 0
  else:
    case2 = dp[1][w0-w[2]] + v[2]
  dp[2][w0] = max(case1, case2)
```

ここまで、特定の w0 について考えていましたが、実際には、w0 = 0,1,...,W のすべてのケースを考えないといけないので、上記のコードでは気を利かせて、w0 のループを回している。

次は、3個目の荷物を含めた場合にいくのですが、このままではキリがないので、一般の n について考えよう。n-1 個目までの荷物だけを使った問題がすでに解けている、すなわち、
- dp[1][0], dp[1][1], ..., dp[1][W]
- dp[2][0], dp[2][1], ..., dp[2][W]
- ...
- dp[n-1][0], dp[n-1][1], ..., dp[n-1][W]

を利用できるという前提で、n 個目までの荷物を容量 w0 のナップサックに詰める問題を解いてみよう。考え方は、2個目の場合と同じ。

- n個目を入れない前提で達成できる最大価値　----- (3)
- n個目を入れる前提で達成できる最大価値　----- (4)

のそれぞれを個別に計算して、得られる最大価値の大きな方を選べばOK。
で、(3) の場合は、「n-1 個目までの荷物を容量 w0 のナップサックに詰める問題」と同じですので、答えは、dp[n-1][w0]

(4) の場合は、**容量 w0 の空のナップサックに先に n 個目の荷物を入れてしまって**、残った「**容量 w0-w[n] のナップサックに対して、 n-1 個目までの荷物を使って、最大価値を実現する入れ方**」を考えればよく、その答えは すでに計算し終えているdp[n-1][w0-w[n]] である。n 個目の荷物の価値とあわせて、(4) の答えは「dp[n-1][w0-w[n]] + v[n]」と決まる。これは、w[n] <= w0 の場合であり、w[n] > w0 の場合は、お約束で 0 。

これらの大きい方を採用すればよいので、コードにすればこうなる。

```python
for w0 in range(0, W+1):
  case1 = dp[n-1][w0]
  if w[n] > w0:
    case2 = 0
  else:
    case2 = dp[n-1][w0-w[n]] + v[n]
  dp[n][w0] = max(case1, case2)
```

さきほどの [code01] と比較すると、1 -> n-1、2 -> n のきれいな置き換えになっていることがわかります。ですので、このコード（[code02]）を n=2,3,...,N まで繰り返せば、無事に dp[N][0],...,dp[N][W] が計算できます。このループも明示的にコードにしちゃいましょう。

```python
# n = 1 の場合
for w0 in range(0, W+1):
  if w[1] <= w0:
    dp[1][w0] = v[1]
  else:
    dp[1][w0] = 0

# n = 2,...,N の場合
for n in range(2, N+1):
  for w0 in range(0, W+1):
    case1 = dp[n-1][w0]
    if w[n] > w0:
      case2 = 0
    else:
      case2 = dp[n-1][w0-w[n]] + v[n]
    dp[n][w0] = max(case1, case2)
```

ここでは、ずっと（？）以前に書いた1個目の荷物だけの答え dp[1] を求めるところもくっつけてあります。ほぼ完璧なコードですね。

で・・・、今、沢山の dp[N][0],...,dp[N][W] が出て来ましたが、一番最初の問題は、**容量 W のナップサックに N 個目までの荷物を詰める場合**なので、この中でも** dp[N][W] が本当に欲しかった答え**ということになります。

# ただこれで提出しても...
いくつかのケースはパスしていますが、実行時間オーバー、メモリーオーバー、ランタイムエラーまで、いろいろ大変なことが起きています。上記のコードは、論理的には正しいのですが、リスト dp[ ][ ] が巨大になりすぎるという欠点を抱えている。

NとWの範囲を見ると$1<= N<= 200, 1<= W<= 10^9$であり、dp[ ][ ] は最大で、$200×10^9$ ものサイズになる。そりゃあランタイムエラーも起きる気がするな～。

巨大な配列を使わずに、これと同等（類似）のロジックを実装する方法を考えてみたい...!





