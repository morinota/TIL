## refs:

- 達人プログラマー24章 契約による設計(DbC)
- はてなさんのブログ: [契約による設計の紹介](https://developer.hatenastaff.com/entry/2016/09/01/163542)
- QiitaのDbCと表明の関係をまとめてくださったブログ: [契約による設計、例外、表明の関係について個人的なまとめ](https://qiita.com/hiko1129/items/f312212070716f672ff6#fn5)

# Design by Contract(契約による設計)とは?

## DbCってなんだっけ?

- ソフトウェアの設計原則の1つ。
  - ソフトウェアコンポーネント間(もしくはUI)の相互作用のための、**明確な契約(Contract)をコード内に定義することによって**、ソフトウェアの信頼性を向上させるための設計原則?
- 契約(Contract)とは??:
  - ソフトウェアコンポーネント(ex. 関数やメソッド)の振る舞いを定義する、規則の集合。

> もしそちらが事前条件を満たした状態で私を呼ぶと約束してくださるならば、お返しに事後条件を満たす状態を最終的に実現することをお約束します。

- 事前条件と事後条件という、宣言的な性質に基づいて関数を設計する。
- 関数とその利用者の間には、↑のような契約があると捉える。

## Contractの3種の主要な要素:

- 1. 事前条件(Preconditions):
  - 機能を呼び出す際に、満たされているべき条件。
  - (ざっくり、呼び出し側が守らなければならない条件...!)
- 2. 事後条件(Postconditions):
  - 機能が動作した後の世界の状態で、この機能が保証する内容。
  - (ざっくり、呼ばれる側が守らなければならない条件...!)
- 3. 不変条件(Invariants):
  - クラスが呼び出し側に対して、常に真となる事を保証する条件。
    - クラスやモジュールの主要なpropertyで、関数やサービスが呼び出される前後で、常に保持されるべき条件。クラスの状態が一貫性を保証するために重要??
  - (ざっくり、呼び出し前、呼び出し後で維持されなければならない性質...!)

(不変条件は、オブジェクト指向を前提とした概念っぽい...?? DbCを提唱したBertrand Meyer氏の書籍が「オブジェクト指向入門」だし...!:thinking:)

## Design by Contractのメリット:

- 信頼性の向上:
  - ソフトウェアコンポーネントが定義された契約に従って動作する事を保証できるので、バグの数を減らし、システム全体の信頼性を向上できる。
  - 正しい関数の使い方が明確になるので...!!->間違いに早く気付ける。
- 再利用性の向上:
  - 契約に基づいて設計されたコンポーネントは、その動作が明確に定義されているため、新しいプロジェクトでの再利用が容易になる。
  - 正しい関数の使い方が明確になるので...!!
- ドキュメントとしての役割:
  - 契約はコードの動作を明確に記述しているので、ドキュメントとしても機能する。これにより、他の開発者がコードを理解しやすくなる。

## 利用シナリオ

- Design by Contractは、特に安全性や信頼性が重要視されるソフトウェアシステムにおいて有効。
- また、大規模なソフトウェアプロジェクトにおいても、コンポーネント間の厳密なインターフェースを保証する手段として役立つ。

# 表明(assertion)

- プログラミングにおける概念のひとつであり、**そのプログラムの前提条件を示すのに使われる。Assertionとも呼ばれる**。表明は、プログラムのその箇所で必ず真であるべき式の形式をとる。
  - (Assertionって表明って意味だったんだ...! 前提条件ってことは、ContractにおけるPreconditionsやInvariantsと類似する概念...??:thinking:)
- 達人プログラマーでの記載:

  - 「もし起こり得ないというのであれば、表明を使ってそれを保証すること」
  - 「本来のエラー処理に表明を使ってはいけない。**表明は起こり得ない事をチェックするためのもの**」
    - -> 起こり得ない事は表明(Assertion)、起こり得る事は例外()...!:thinking:

- (「契約をコードで表現する」ってことは、つまり表明するってことか...?:thinking:)

# 要求型の関数と保護型の関数

- 要求型:
  - 呼び出し側が事前条件を満たす事を要求する関数。
- 保護型:
  - どんな入力でも、なんとかして処理する関数。

意識して使い分けよう!
ドメインロジックでは、要求型がおすすめ! (じゃあ逆に、インターフェースには保護型がおすすめ??)

- 使う型に強い条件を課す事で、関数が正しく動作する事を強制できる。
- 異常な入力を処理するコードがなくなり、コアロジックに集中したシンプルなコードになる。
- 異常な入力をどのように制御するかは使う側のみで決めるので、責任の所在が明らか。
