## link

- https://note.com/yoshi0214/n/n735cd61d2568
- https://learning.oreilly.com/library/view/architecture-patterns-with/9781492052197/part01.html#part1

## Why Do Our Designs Go Wrong? なぜ私達のデザインは間違っていくのか...?

## Encapsulation(カプセル化) と Abstractions(抽象化)

Encapsulation(カプセル化)とAbstractions(抽象化)は、我々全員がこれらの正確な単語を使用していなくても、プログラマーとして本能的に到達する方法論である.
それらは本の繰り返しの背景テーマであるため、少しの間それらについて詳しく説明する.

- Encapsulation(カプセル化)という用語は、以下の**2つの密接に関連するアイデア**をカバーしている。
  - simplifying behavior(**動作の簡素化**)
  - hiding data(**データの非表示**)
- コードで実行する必要のある**タスクを識別**し、**そのタスクを明確に定義されたオブジェクトまたは関数に渡す(任せる)**ことで、動作をEncapsulationする.
  - ここで、**タスクを渡された(任された)オブジェクトまたは関数をAbstractions(抽象化したもの, 抽象化表現)**と呼ぶ.

### 例

次の2つのPythonコードスニペットを見てください.

```python
import json
from urllib.request import urlopen
from urllib.parse import urlencode

params = dict(q='Sausages', format='json')
handel = urlopen('http://api.duckduckgo.com' + '?' + urlencode(params))
raw_text = handle.read().decode('utf8')
parsed = json.loads(raw_text)

results = parsed['RelatedTopics']
for r in results:
    if 'Text' in r:
        print(r['FirstURL'] + ' - ' + r['Text'])
```

```python
import requests
params = dict(q='Sausages', format='json')
parsed = requests.get('http://api.duckduckgo.com/', params=params).json()

results = parsed['RelatedTopics']
for r in results:
    if 'Text' in r:
        print(r['FirstURL'] + ' - ' + r['Text'])
```

どちらのコードリストも同じことを行う: 検索エンジンAPIを使用するために、フォームにエンコードされた値をURLに送信する.
しかし、2つ目は、**より高いレベルのAbstractions(抽象化したもの, 抽象化表現)で動作する**ため、**読みやすく、理解しやすい**ものである.

コードで実行する**タスクを特定して名前を付け**、**さらに高レベルのAbstractions(抽象化)を使用して明示的に**することで、これをさらに一歩進めることができます。

```python
import duckduckgo
for r in duckduckgo.query('Sausages').results:
    print(r.url + ' - ' + r.text)
```

- **Abstractions(抽象化)を使用して動作をEncapsulation(カプセル化)する**ことは、コードをより表現力豊かで、テストしやすく、保守しやすくするための強力な方法である.
- **object-oriented (OO, オブジェクト指向)**の世界の文献では、このアプローチ(カプセル化&抽象化)の古典的な特徴の1つは、**responsibility-driven design(責任主導型設計)**と呼ばれている.
  - responsibility-driven design(責任主導型設計): データやアルゴリズムではなく、**動作の観点から**コードについて考えるという意味

## Abstractions(抽象化) と ABCs

- JavaやC＃などの従来のオブジェクト指向言語では、**abstract base class (ABC, 抽象基本クラス)**、または**インターフェース**を使用してAbstractions(抽象化)を定義できる.
- Pythonでは、ABCを使用できる（場合によっては使用します）が、duck typingに頼ることもできます。
  - duck typingとは:
    - Python、Ruby、JavaScriptなどの**動的型付けに対応したオブジェクト指向プログラミング言語**に特徴的な、型付けのスタイル（作法）のひとつ.
    - Pythonのリファレンスでは、ダック・タイピングは「あるオブジェクトが正しいインタフェースを持っているかどうかを決定するために、オブジェクトの型を見ることはしないプログラミングスタイルである」代わりに、オブジェクトが持つメソッドや属性（フィールドまたはプロパティ）が単純に呼ばれたり使われたりする.
    - つまり、ダックタイピングを使った言語では、オブジェクトのタイプはそのクラスの継承や特定のインタフェースの実装によってではなく、その**オブジェクトが持つメソッドやプロパティによって**決まる.
    - 要するに、「**型宣言しませんよ!でも呼ばれてるメソッドで理解してね!**」みたいなスタイル??
- また、Abstractions(抽象化)は、単に「使用しているもののパブリックAPI」を意味する場合があります。

  - たとえば、関数名といくつかの引数.

- この本のパターンのほとんどはAbstractions(抽象化)の選択を伴う(ダックタイピングではなく...!)ため、各章にたくさんの例がある。
- さらに、第3章では、Abstractions(抽象化)を選択するためのいくつかの一般的な**heuristic(ヒューリスティック, 発見的手法)**について具体的に説明する.
  - heuristic: ヒューリスティック, 発見的手法
    - 心理学用語.
    - 必ずしも正しい答えではないが、経験や先入観によって直感的に、ある程度正解に近い答えを得ることができる思考法.
    - 「**経験則**」と同義であるとも言われる.

## Layering(階層化)

- Encapsulation(カプセル化) & Abstractions(抽象化)は、詳細を非表示にし、データの一貫性を保護することで役立つが、**オブジェクトと関数の間の相互作用にも注意を払う必要**がある...!!
  - 1つの関数、モジュール、またはオブジェクトが別の関数を使用する場合、「一方が他方に**依存**している」と言う.
  - これらの依存関係は、一種の**ネットワークまたはグラフを形成**する.
  - 大きな泥だんごでは、依存関係は制御不能.（図P-1, たぶん依存関係が行ったり来たりしてる、みたいな...?）。
  - **グラフの1つのノードを変更すると、システムの他の多くの部分に影響を与える可能性がある**ため、変更が困難になってしまう.

![fig p-1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492052197/files/assets/apwp_0001.png)

- **layered architecture(階層化アーキテクチャ)**は、この問題(依存関係がぐちゃぐちゃになる.)に取り組む1つの方法である.
  - layered architecture(階層化アーキテクチャ)では、コードを個別のカテゴリまたはロールに分割し、コードのどのカテゴリが相互に呼び出すことができるかについてのルールを導入する.
  - 最も一般的な例の1つは、図P-2に示す**3層アーキテクチャ**です.

![fig p-2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492052197/files/assets/apwp_0002.png)

- layered architecture(階層化アーキテクチャ)は、おそらくビジネスソフトウェアを構築するための最も一般的なパターンである.
  - このモデルには、Webページ、API、またはコマンドラインなどの**ユーザーインターフェイスコンポーネント**がある.
  - これらのユーザーインターフェイスコンポーネントは、ビジネスルールとワークフローを含む**ビジネスロジックレイヤー**と通信する.
  - そして最後に、データの保存と取得を担当する**データベースレイヤー**がある.
- この本の残りの部分では、1つの単純な原則に従うことによって、このモデルを体系的に裏返しにする.

## Dependency Inversion Principle(DIP, 依存性逆転の原則)

- **Dependency Inversion Principle(DIP, 依存性逆転の原則)**は、**SOLIDのD**であるため、既にご存知かもしれない.(...??)
  - 残念ながら、Encapsulation(カプセル化)の場合のように3つの小さなコードリストを使用してDIPを説明することはできない.
  - ただし、パートI全体は、基本的にアプリケーション全体にDIPを実装する実際の例であるため、具体的な例をすべて紹介する.
- それまでの間、DIPの正式な定義について.
  - 1. **High-levelモジュールはlow-levelモジュールに依存すべきでない**.
    - どちらもAbstractions(抽象化)に依存する必要がある.
  - 2. Abstractions(抽象化)はdetails(詳細)に依存するべきではない。
    - 代わりに、details(詳細)はAbstractions(抽象化)に依存する必要がある

これらはどういう意味だろうか？少しずつ見ていきましょう...!!

- **High-levelモジュール**:組織が本当に気にかけているコード.
  - ex)おそらくあなたは製薬会社で働いており、高レベルのモジュールは患者と治験を扱っています。
  - ex2)おそらくあなたは銀行で働いており、高レベルのモジュールが取引と取引所を管理しています。
  - ソフトウェアシステムのHigh-levelモジュールは、**私たちの実際の概念を扱う関数、クラス、およびパッケージ**.
- **Low-levelモジュール**: 組織が気にしないコード.
  - ex)
    - ex)人事部門がファイルシステムやネットワークソケットに興奮することはまずない.
    - ex2)SMTP、HTTP、またはAMQPについて財務チームと話し合うことはめったにありません。
  - **技術者以外の利害関係者**にとって、これらの**低レベルの概念は興味深くなく、関連性がない**。
    - 彼らが気にするのは、高レベルの概念が正しく機能するかどうかだけ。
    - 給与計算が時間どおりに実行される場合、それがcronジョブであるか一時的な実行であるかをビジネスが気にする可能性は低く、それがcronジョブであるかKubernetesで実行される一時的な関数であるかを気にする可能性は低くなる.
- "依存する":
  - **必ずしもインポートや呼び出しのみを意味しない**.
  - **あるモジュールが別のモジュールを知っている、または必要としている**という、より一般的な考え方.
- 抽象化：
  - すでに説明した通り.
  - 抽象化は、**duckduckgoモジュールが検索エンジンのAPIをカプセル化する**ように、**動作をカプセル化する単純化されたインターフェース**である.

> All problems in computer science can be solved by adding another level of indirection. コンピュータサイエンスのすべての問題は、別のレベルの間接参照を追加することで解決できます。 ―David Wheeler

- したがって、DIPの前半部分では、「**ビジネスコード(high level)は技術的な詳細(low level)に依存すべきではない(=知っているべきではない!)**」と述べている.
- 代わりに、**両方とも抽象化を使用する必要がある**.
- なぜ?
  - ->大まかに言って、私たちは**それらを互いに独立して変更できるように**したいから.
    - 高レベルのモジュールは、ビジネスニーズに応じて簡単に変更できる必要がある.
    - 低レベルのモジュール（詳細）は、実際には変更が難しいことがよくある.
  - ex)
    - 関数名を変更するためのリファクタリングと、列名を変更するためのデータベース移行の定義、テスト、および展開について考えてください。
    - ビジネスロジックの変更は、低レベルのインフラストラクチャの詳細と密接に関連しているため、速度が低下することは望ましくない.
    - ただし、同様に、**ビジネスレイヤーに変更を加えることなく**、必要なときにインフラストラクチャの**詳細を変更できること**が重要.
      - (ここでいうビジネスレイヤーは、クライアントサイドやフロントエンド的な解釈でも問題なさそう...??)
    - それらの間に抽象化（有名なindirection(間接参照)の追加レイヤー）を追加すると、**2つを互いに独立して（さらに）変更できる**。
      - 3層に分かれている階層化アーキテクチャをイメージ...!!!

第二部はさらに神秘的。(??)

- 「**Abstractions(抽象化)はdetails(詳細)に依存すべきではない**」は十分に明確に思えるが、「details(詳細)はAbstractions(抽象化)に依存すべきである」とは想像しがたいものである.
- "抽象化されている詳細"に依存しない抽象化をどのように行うことができるだろうか...？
- 第4章に到達するまでに、この件をもう少し明確にする具体的な例がある！今はわからなくて良い！

## A place for All Our Business Logic: The Domain Model, すべてのビジネスロジックのための場所: ドメインモデル

- しかし、3層アーキテクチャを裏返しにする前に、**その中間層(?)である高レベルモジュールまたはビジネスロジックについて**詳しく説明する必要がある.
- 私たちの設計がうまくいかない最も一般的な理由の1つは、**ビジネスロジックがアプリケーションのレイヤー全体に広がり**、識別、理解、および変更が困難になること.
  - 第1章では、**Domain Model pattern**を使用してビジネスレイヤーを構築する方法を示す.
  - パートIの残りのパターンは、**適切な抽象化を選択**し、**DIPを継続的に適用**することで、Domain Modelを簡単に変更し、低レベルの懸念から解放(...???)する方法を示している.

## 補足

- 1. responsibility-driven design(責任主導型設計)について
  - CRC（Class-responsibility-collaborator） カードを見たことがあるなら、それは同じことを意味します：責任について考えることで、物事の分担を決めることができます。
- 2. SOLIDとは、ロバート・C・マーティンのオブジェクト指向設計の5原則:
  - single responsibility(単一責任)
  - open for extension but closed for modification(拡張はオープンだが改変はクローズ)
  - Liskov substitution(リスコフ置換)
  - interface segregation(インターフェース分離)
  - dependency inversion(依存関係逆転)
  - ↑の頭文字をとったもの。
  - S.O.L.I.D: The First 5 Principles of Object-Oriented Design" (Samuel Oloruntoba著)を参照。
