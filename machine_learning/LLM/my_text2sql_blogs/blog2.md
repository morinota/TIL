## これは何?

- Text2SQLサービスの実現のために、個人的に情報収集した内容を雑多にまとめたものです。
- ２回目は、Text2SQLの既存の事例を調べてみています。

## Linkedinさんの事例

- 参考: https://www.linkedin.com/blog/engineering/ai/practical-text-to-sql-for-data-analytics

### 導入

- モチベーション
  - **テック企業のデータ専門家は、同僚が必要とするデータを見つける手助けに多くの時間を費やす**。
  - このボトルネックはデータチームを苛立たせるだけでなく、**重要な洞察を待っているビジネスパートナーに遅延**を引き起こす。
- 解決策
  - データ民主化の取り組みの一環として、Text2SQLのBotを開発・導入した。
  - 導入されたBotは、**LangChainとLangGraphで実装されたマルチエージェントシステム**。
    - ここでマルチエージェントっていうのは、SQLのgeneratorとreviewerがいて、それぞれがAgenticにアクションを決定する、みたいな感じなんだろうか...!:thinking:
- 本ブログで記述されるのは、**実用的なText2SQLソリューションをデプロイするために採用した重要な戦略たち**。
  - 現在は、LinkedInの多様なビジネス分野で数百人の従業員がこのBotを使用してるらしい。(ちゃんとPoCで終わらせずに普及させてるのが凄い...!:thinking:)

### 戦略1: 高品質なテーブルメタデータとパーソナライズされたretreival

- Embedding-Based Retrieval(EBR)に基づくRAGを採用
  - **Text2SQLタスクはしばしばRAGアプリケーションとして位置付けられる**。
    - なんで??
      - Text2SQLのタスクを精度高く解くためには、テーブルスキーマ、サンプルクエリ、その他のドメイン知識などが必要。
      - よって、LLM自身の内部知識のみでは不十分であり、Context Constructionが必要。
      - Context Constructionの一番有名な手法がRAG(Retriever-Reader-Generator)
    - 本事例では特に、**EBRに基づくRAGを採用して、Context Constructionを実装してる**みたい。
- RAGの精度を高めるための工夫たち。
  - 課題1: テーブルの説明文の頻繁な欠如や不完全さ。
    - 対応策: 数百の重要なテーブルの包括的な説明を収集するための、dataset certificationという取り組み。
      - **各ドメインエキスパートに依頼して、自分の分野内の重要なテーブルを特定**し、必須のテーブル説明と任意のフィールド説明を書いてもらった。
      - 説明文は、既存の文書やSlackの履歴に基づいたLLMによる注釈で補完された。
        - (人手でメタデータを整備してから、LLMに整形させるパターン??:thinking:)
  - 課題2: とにかくテーブル数の膨大さと、ユーザの質問に含まれる暗黙的なコンテキスト。
    - 前者への対応: **アクセスの人気を見ることで、テーブルの数を数千に簡単に絞り込める**。
    - 後者への対応: **組織図に基づいてユーザのデフォルトデータセット(=たぶんテーブル集合!)を推測**するようにした。
      - ex. 「昨日の平均CTRは何でしたか？」という質問は、ユーザがメール通知、広告、または検索品質に興味があるかどうかによって異なる答えが必要。
      - たぶんEBRに基づくRAGをする前のテーブル集合を、パーソナライズするような感じ!
        - ユーザは必要に応じてデフォルトのフィルタ値(RAG対象のテーブル集合)を変更することができる。
- 新しいテーブルやフィールドを自動で取り込むための工夫。
  - 実務上、テーブルやフィールドは時間とともに廃止されたり追加されたりする。
  - 新しいテーブルを取得するプロセスを自動化するために、**人気のあるテーブルを自動的にベクターストアに取り込む**ようにした。
  - また、**ユーザがテーブルやフィールドを「deprecated」マークできる**ようにした。
    - →このフラグを元に、テーブルやフィールドを自動的にオフボード(退職)させるプロセスを実装した。

### 戦略2: 正確なクエリを生成させるのに役立ったアプローチたち

- 知識グラフの活用
  - ユーザ、テーブルクラスタ、テーブル、フィールドがノードになる。
    - ユーザとテーブルクラスタが紐づく。テーブルはテーブルクラスタに含まれる。フィールドはテーブルに含まれる。
  - 各ノードは属性を持つ。
- **EBR-RAGした結果に対して、知識グラフ&LLMを使って、再フィルタリング&ソートする**。
  - 具体的には、EBRを介して上位20のテーブルを取得した後、クエリ作成のために上位7のテーブルを選択するためにLLM再ランキングを使用する。
  - テーブル選択の入力: テーブルの説明、サンプルクエリ、Botから入力されるドメイン知識、ユーザの質問で検出された内部用語の説明。
- 再ランキングされたテーブルに対して、関連度の高いフィールドを選択するために、さらに別のLLMでランキングする。
  - フィールド選択の入力: テーブル選択に使用される情報、フィールドの説明、上位K個のフィールドのサンプル値、最近のアクセス頻度、など。
- iterativeなクエリ作成プロセス:
  - まず計画を生成し、最終クエリを構築するために計画の**各ステップを段階的に解決**させる。
    - (分業させるのが有効なのか...!:thinking:)
  - 前のステップの入出力は、次のステップで活用するために、botの内部状態に保持される。
  - この方法は複雑な質問には効果的。
    - 一方で、単純な質問に対して過度にステップを踏んでしまうことがあるので、最初の計画時に生成するステップの数を最小限に抑えるように指示しておく。
      - -> これにより、単純な質問のクエリが簡潔になり、複雑な質問に対するパフォーマンスが維持される。
- validetorによる自動エラーチェック & 修正
  - 生成されたSQLについて、**テーブルとフィールドの存在を確認し、クエリに対してEXPLAIN文を実行して構文やその他のエラーを検出** (このあたりは簡単に真似できそう!)
  - もしエラーがあったら、自己修正エージェントに送られる。エージェントには、必要に応じてクエリを更新する前に追加のテーブルやフィールドを取得するためのツールが装備されてる。
    - (**なるほど、クエリ修正時に、RAGからやり直すべきか、生成ステップだけで良いか、みたいな判断をLLM側にやらせる**って話...!うんうん、Agenticだ:thinking:)

### 戦略3: リッチなチャット機能を用いたユーザ体験

- ユーザ体験は、アプリを使ってもらうための中心的な要素。
  - 特にユーザは、**使いやすさと迅速なレスポンスを重視**する。

- Text2SQL Bot を 分析プラットフォームに統合!
  - SQL Botを自社の分析プラットフォームに直接統合し、**ユーザがクエリを作成して実行する際に同じブラウザウィンドウ内でアクセスできる**ようにした!
  - この工夫により、standaloneなアプリとして稼働させたプロトタイプ時と比較して、利用率が5~10倍に向上したらしい!
  - 具体的には...
    - 分析プラットフォームのサイドバーにSQL Botへのエントリーポイントを配置。
    - クエリが失敗するたびに、「AIで修正」ボタンが表示。
    - **チャット履歴は保存され、ユーザは以前の会話を続けることができる**。
    - ユーザは製品内フィードバックを送信したり、ボットの動作をパーソナライズするためのカスタム指示を追加できる。
- ユーザはクエリ生成以外の用途でも使いたい!
  - 初期プロトタイプはすべての質問にSQLクエリで回答するようにしてた。
  - しかし実際にはユーザは、**テーブルを見つけたり、データセットに関する質問をしたり、参考クエリを見たり、クエリ構文に関する一般的な質問をしたい**、と考えてた。
  - 現在は意図分類器を手前に追加して、質問を分類し、レスポンス方針を決定するようになった。
- クイックアクションの提供
  - **チャットボットが会話形式であることは重要**であり、ユーザが**フォローアップの質問**をすることができる。
    - (うんうん、ユーザが補足情報を書き足して出力を調整できるという点で、会話形式であることが重要だよなぁ...!:thinking:)
  - クイックアクションとして、「クエリを更新」、「テーブル選択を更新」、「これらのテーブルを説明」などを提供し、ユーザが試すことができるフォローアップの種類を案内するようにした。(UIの工夫!)
- ガイド付きモードオプションの提供。
  - SQL Botがクエリ作成プロセスの各ステップを案内しながら行う。
  - これにより、**ユーザはクエリを理解し、クエリ作成プロセスに対するコントロールを強化できる**
- ユーザがボットの出力を理解できるように、テーブル & クエリの**リッチ表示要素**を追加。
  - テーブルのリッチ表示要素:
    - 取得したテーブル、その説明、データセットが「認定」または「人気」であるかを示すタグ、平均月間アクセス頻度、一般的に結合されるテーブル、および詳細情報のためのDataHubへのリンク
  - クエリのリッチ表示要素:
    - フォーマットされたクエリ、説明、およびテーブルが存在するか、フィールドが存在するか、構文が正しいかの検証チェック
  - これにより、ユーザはBotの出力を理解し、修正が必要な問題を特定できる。結果として、ユーザーはボットに更新を依頼することができる。

### 戦略4: ユーザカスタマイズのオプション

- 利用するデータセットのカスタマイズ
- カスタム指示
- ユーザによるサンプルクエリの追加

### 戦略5: 継続的なbenchmarking

- LLM-as-a-Judgeによる評価
- 130以上のベンチマーク質問
- 再ランキングやメタデータ追加による改善

### まとめ & 今後の展望
