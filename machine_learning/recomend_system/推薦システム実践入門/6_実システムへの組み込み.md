本章では、次の項目について、推薦システムを構築する為に必要な考え方や設計のパターンをまとめる

- バッチ推薦/リアルタイム推薦
- 推薦システムの設計パターン
- 多段階推薦や近似最近傍探索による工夫
- ログの設計
- ニュースサービスにおける実例

# 1. システム概要

## 1.1. バッチ推薦とリアルタイム推薦

MLを推薦システムに組み込むには、モデルの学習、特徴量の抽出/更新、予測をどのような頻度やタイミングで行うかが重要

- バッチ推薦
  - モデルの学習：バッチ
  - 特徴量の抽出/更新：バッチ
  - 予測：バッチ
- リアルタイム推薦
  - モデルの学習：バッチ or リアルタイム
  - 特徴量の抽出/更新：リアルタイム
  - 予測：リアルタイム

バッチ推薦とリアルタイム推薦は、サービスにおける**アイテムやユーザ情報のフレッシュネスの要求レベル**に応じて使い分ける。
「フレッシュネスの要求」とは、「新しいアイテム or ユーザ情報 or ユーザ行動データ等が利用可能になった時点(ex. **データベースに最初に格納された時点**)から、**実際に推薦に活用されるまでの時間差がどれほど小さく要求されるか**」を意味する。

- フレッシュネスの要求と、各種推薦システムの相性
  - バッチ推薦
    - アイテムやユーザの新規追加や、更新頻度が少なく、フレッシュネス要求が比較的低い場合に適している。
    - ex)
      - アイテムからアイテムへの推薦
      - プッシュ通知やダイレクトメール配信等
  - リアルタイム推薦
    - アイテムやユーザの新規追加や更新が多く、フレッシュネスが高いレベルで求められるサービス。
    - ex)
      - ニュースや音楽等のドメイン領域における、ユーザへのパーソナライズ。
    - リアルタイム推薦では、ユーザのリクエストに応じてリアルタイムにユーザの興味に合わせた推薦を目指す。
      - ex)ユーザが音楽サービスにおいて曲をスキップした時に、スキップしたというフィードバックを、推薦のモデルにリアルタイムに反映させる！
      - =>次の推薦機会ではスキップした曲とは類似度の遠い曲を推薦する事ができる。

## 1.2. 代表的な推薦システム概要

次に代表的かつシンプルな設計パターンを３つ紹介。

### 1.2.1. 概要推薦

- 新規順や人気順でアイテムを表示する。
- 新規順
  - 最も単純な新規順の推薦の設計は、データベース(DB)にアクセスして新規順にアイテムをソートするクエリを実行する方法。
  - データベースに直接アクセスするので、リアルタイム性を考慮した推薦を行う事ができる。
- 人気度順
  - バッチ型のシステム構成をとるのが一般的。
  - **数時間に一回または一日一回等の頻度で、人気度の集計を行い、その結果をデータベースに格納**しておく。
  - アプリケーション側は、その結果をデータベースを介して取得して、画面に表示する。
- (＋α)
  - カテゴリやユーザ属性毎に人気度を計算し、結果をデータベースに格納しておくことで、人気度の概要推薦の中でも粒度の細かい推薦を行う事もあり！！

### 1.2.2. 関連アイテム推薦

- **事前に類似度の計算を行い、類似するアイテム群をデータベースに保存し結果を返却する**方法。
  - 類似アイテムの計算は、行動ログを使うものや、コンテンツ特徴量を使うもの等様々。
  - ex)
    - ウェブアプリケーションは、アイテムを一意に識別するitem_idを含むクエリをデータベースに発行。
    - =>DBは、事前に計算されていた類似アイテムをウェブアプリケーションに返却。
- ウェブアプリケーションとデータベースの間に、推薦APIを経由する方法：
  - 「特定のユーザに出してはいけないアイテムの除外」等を処理をしたい場合には、推薦API内に除外する処理を組み込みやすい。
  - また、**推薦APIにユーザを一意に識別するuser_idを渡す事で、「ユーザに応じて類似度計算アルゴリズムを変える」A/Bテストを実行可能**！！
  - この場合のA/Bテストでは、**ウェブアプリケーション側のコードを変更する事なく、新しい類似度算出アルゴリズムを試す事ができる**メリットがある！

### 1.2.3. パーソナライズ推薦

- バッチ側のパーソナライズ推薦：
  - 事前に各ユーザ毎にオススメのアイテムを計算してデータベースに保存。
  - この設計では、**それぞれのPersonalizeアルゴリズムの結果をそれぞれ保存しておく**ことで、パーソナライズ結果を組み合わせてユーザに提示できる。
- アプリケーションとデータベースの間に推薦APIを挟む方法：
  - 前述の"関連アイテム推薦"の設計と同様のメリット！
  - アイテムの除外ロジック等を組み込みやすい。
  - **A/Bテストがしやすい**。
- (近年活用が増えてるらしい！)ベクトルベースのパーソナライズ：
  - この設計では、機械学習手法を用いて、ア**イテムとユーザの特徴をベクトル化**し、データベースに保存する。
  - 推薦APIは、アプリケーションからuser_idをパラメータとして渡され(リクエストされ)、アイテムとユーザのベクトルの類似度を元にオススメアイテムを返却する。
  - アイテムのベクトル化：
    - ユーザ行動をitem2vecによってベクトル化する方法。
    - タイトル等のコンテンツ情報を深層学習モデルに入力してベクトル化(特徴抽出)する方法
  - ユーザのベクトル化：
    - ユーザが過去にクリックした各アイテムのベクトルの平均をユーザのベクトルとする方法。
    - 近年では、ユーザの過去にクリックしたアイテムのベクトルを時系列にそってRNNモデルへ入力し、ベクトル化する事もある。

## 1.3. 多段階推薦

多くの場合、多くのユーザを抱えるサービスにおける推薦では、**システムの負荷を考慮した設計**が不可欠。
**システム負荷を低く保ちつつ精度の高い推薦を行う**為に、「候補選択」「スコアリング」「リランキング」の**多段階に処理を分ける工夫(=多段階推薦)**がある。

なお「候補選択」と「スコアリング・リランキング」の２つに分け、二段階推薦(Two-stage Recommendation)と呼ばれる事もある。

この多段階の処理では、**まず粗くアイテムの候補を絞り(100~10000アイテム)**、アイテム候補数が少なくなった段階で、よりユーザや状況に適したアイテムを**精度の高いモデルによって厳選(10~100アイテム)**する、といった処理を行う。

### 1.3.1. 候補選択

- 第一段階。
- 膨大なアイテムから推薦候補となるアイテムを抽出する処理。
  - ex)動画共有サービスのYouTubeでは、候補選択の段階で数十億ある推薦アイテム候補を100~10000個に削減する。
- 候補選択の処理は...
  - 各ユーザリクエストに対し高速にアイテムを返却する為の**前処理に相当**する。
  - 膨大なアイテムに対して実行する必要がある為、**処理の軽さが求められる**。
  - また、単一の選択ロジックである必要はない為、**複数の候補選択ロジックを組み合わせる**事で、多様な観点から候補アイテムを抽出することもできる。

### 1.3.2. スコアリング

- 第二段階。
- 実際にユーザに掲出するアイテムを選択する為に、**アイテムに対してスコアを与える処理**。
  - 候補選択によって**スコアリング対象が十分削減されている**ので、**負荷の高いモデル、特に機械学習モデルによる高精度な推論を活用する**事が多い。
- ex)Instagramの推薦では...
  - 候補アイテムを抽出した後に、**複数のスコアリング処理**を行い最終的な推薦リストを作成している。
  - 複数のスコアリング処理では、500の候補があった時に、**粗いモデルから精緻なモデルを多段階で順に適用**し、150, 50, 25と候補を絞っていく。

### 1.3.3. リランキング

- 第三段階。
- スコアリングで選択されたアイテムを並び替える処理。
- ここでは、例えば以下の処理を行う。
  - ランキング全体のバランスを考慮して、**似通ったアイテムばかり並ばないようにする**処理。
  - **アイテムの鮮度**を考慮して並び替える処理。
- このように、リランキングは多様性、鮮度、コンテンツ特有の情報を用いて、**ユーザ体験やビジネスロジックを考慮した推薦を実現する為**に行われる。

## 1.4. 近似最近棒探索

# 2. ログの設計

## 2.1. クライアントサイドのログ

## 2.2. サーバーサイドのログ

## 2.3. ユーザ行動ログの具体例

# 3. 実システムの例1

## 3.1. バッチ推薦

## 3.2. リアルタイム推薦

# 4. まとめ
