<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.168">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="NewsPicks Data/Algorithm unit インターン 森田大登">
<meta name="dcterms.date" content="2023-04-24">

<title>twitterの様々な推薦機能で活用されてるらしい、ユーザ-ユーザのフォローネットワークからコミュニティ埋め込み表現を生成するSimClustersの論文を読んだ</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="slides_files/libs/clipboard/clipboard.min.js"></script>
<script src="slides_files/libs/quarto-html/quarto.js"></script>
<script src="slides_files/libs/quarto-html/popper.min.js"></script>
<script src="slides_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="slides_files/libs/quarto-html/anchor.min.js"></script>
<link href="slides_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="slides_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="slides_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="slides_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="slides_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">twitterの様々な推薦機能で活用されてるらしい、ユーザ-ユーザのフォローネットワークからコミュニティ埋め込み表現を生成するSimClustersの論文を読んだ</h1>
<p class="subtitle lead">n週連続 推薦システム関連の論文読んだシリーズ13週目(毎週水曜更新)</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>NewsPicks Data/Algorithm unit インターン 森田大登 </p>
          </div>
  </div>

    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 24, 2023</p>
    </div>
  </div>

  </div>


</header>

<section id="この論文を選んだ経緯" class="level2">
<h2 class="anchored" data-anchor-id="この論文を選んだ経緯">この論文を選んだ経緯</h2>
<ul>
<li>2023/04/01頃に、twitterの推薦アルゴリズムの一部(“For Youフィード” -ツイート推薦の機能)が、ソースコード + techブログによる解説という形で公開されました。</li>
<li>その中で今回は、twitterの様々な推薦機能で共通基盤として活用されているらしい <strong>SimClusters</strong> という手法によるユーザ + 各種コンテンツの埋め込みベクトルの生成手法に注目しました。</li>
<li>SimClutersは、<strong>ユーザ-ユーザのフォローネットワークからコミュニティを発見</strong>して、コミュニティ埋め込みベクトル(SimCluters表現)を作ります。(SNS特有の手法…? <span class="emoji" data-emoji="thinking">🤔</span>)</li>
<li>NewsPicksは経済ニュースサービスの性質に加えてSNSの側面もあるので、ユーザやキーワードフォローの情報の活用可能性もあるのでは…? <span class="emoji" data-emoji="thinking">🤔</span></li>
<li>また、現在NewsPicksでは関連記事やプッシュ通知パーソナライズ等、複数の推薦機能が稼働中or予定なので、“共通基盤”という言葉に惹かれました。</li>
</ul>
</section>
<section id="参考" class="level2">
<h2 class="anchored" data-anchor-id="参考">参考:</h2>
<ul>
<li><a href="https://www.kdd.org/kdd2020/accepted-papers/view/simclusters-community-based-representations-for-heterogeneous-recommendatio">SimClustersの論文</a></li>
<li><a href="https://blog.twitter.com/engineering/en_us/topics/open-source/2023/twitter-recommendation-algorithm">公開されたtechブログ</a></li>
<li><a href="https://github.com/twitter/the-algorithm">公開されたgithub リポジトリ</a></li>
</ul>
</section>
<section id="simclusters論文の基本情報" class="level2">
<h2 class="anchored" data-anchor-id="simclusters論文の基本情報">SimClusters論文の基本情報</h2>
<ul>
<li>title: SimClusters: Community-Based Representations for Heterogeneous Recommendations at Twitter.</li>
<li>(“for Heterogeneous Recommendations” 性質の異なる複数の推薦機能達の為の…<span class="emoji" data-emoji="thinking">🤔</span>)</li>
<li>published date: August 2020,</li>
<li>authors: Wondo Rhee, Sung Min Cho, Bongwon Suh</li>
<li>url(paper): <a href="https://www.kdd.org/kdd2020/accepted-papers/view/simclusters-community-based-representations-for-heterogeneous-recommendatio">https://www.kdd.org/kdd2020/accepted-papers/view/simclusters-community-based-representations-for-heterogeneous-recommendatio</a></li>
</ul>
</section>
<section id="どんなもの" class="level2">
<h2 class="anchored" data-anchor-id="どんなもの">どんなもの?</h2>
<ul>
<li>twitter の <strong>SimClusters (Similarity-based Clusters)</strong>というコミュニティ埋め込みベクトルを生成する手法の論文.</li>
<li>「K-POP」や「機械学習」といった共通の話題や、「職場が一緒」「高校が一緒」といった社会的関係から構成されるTwitter上のコミュニティ（約 10^5件）を発見し、ユーザやコンテンツと各コミュニティの関連を表す埋め込みベクトルを生成する.</li>
<li>様々な推薦タスクに活用できる、汎用的な埋め込み表現であるとの事.(論文の後半のオンライン実験にて、活用法を紹介していた.)</li>
</ul>
</section>
<section id="simclustersのモチベーション" class="level2">
<h2 class="anchored" data-anchor-id="simclustersのモチベーション">SimClustersのモチベーション</h2>
<ul>
<li>Twitterでは多種のアイテムに対して推薦機能がリリースされている:Tweet, Event, Topic(NPにおけるキーワード的な位置づけらしい), ハッシュタグ, ユーザ</li>
<li>推薦アイテム達はそれぞれ異質(Heterogeneous)である：Item Cardinality(=計算のスケーラビリティに影響を与える)とShelf Life(推薦生成のlatencyに制約を与える. 賞味期限的なもの)が異なる(table 1参照)</li>
<li>これまでTwitterは、<strong>これらの異なる推薦問題に個別に対応するシステムを構築しており、再利用や共通化はほとんど行われていなかった</strong>。</li>
</ul>
<p><img src="https://imgur.com/5o4mPI5.png" class="img-fluid"></p>
</section>
<section id="shelf-life-が異なるケースって例えばなんだっけ" class="level2">
<h2 class="anchored" data-anchor-id="shelf-life-が異なるケースって例えばなんだっけ">Shelf Life が異なるケースって例えばなんだっけ</h2>
<ul>
<li>フォロワーグラフ(フォロー関係のネットワーク)は比較的ゆっくりと変化するため、ユーザフォローの推薦は数週間にわたってユーザ嗜好との関連性を保つことができる(したがって、<strong>バッチ処理で計算することができる</strong>)</li>
<li>一方で、ツイート推薦は陳腐化するのが早い(i.e.&nbsp;lifespanが短い<span class="emoji" data-emoji="thinking">🤔</span>)為<strong>オンラインシステムでリアルタイムに近い形で生成する必要があり</strong>、この場合、バッチ計算では要件を満たせない.</li>
<li>NPの例で言えば、通常の経済ニュースはShelf Lifeは短め。(ツイートよりは長そうだが、shelf lifeは2~3日?<span class="emoji" data-emoji="thinking">🤔</span>)</li>
<li>NPオリジナル記事やオリジナル動画、トピックス(=専門家による記事)等は、もっとShelf life長い気がする<span class="emoji" data-emoji="thinking">🤔</span></li>
<li>ユーザやキーワードは更にshelf lifeが長いはず<span class="emoji" data-emoji="thinking">🤔</span></li>
</ul>
</section>
<section id="simclustersのモチベーション-1" class="level2">
<h2 class="anchored" data-anchor-id="simclustersのモチベーション-1">SimClustersのモチベーション</h2>
<section id="目的" class="level4">
<h4 class="anchored" data-anchor-id="目的">目的:</h4>
<ul>
<li>異質(Heterogeneous)な全て or ほとんどの推薦機能の性能を高めるのに役立つ共通基盤的なシステムを構築したい…!</li>
</ul>
</section>
<section id="解法" class="level4">
<h4 class="anchored" data-anchor-id="解法">解法</h4>
<ul>
<li><strong>ユーザ-ユーザグラフからコミュニティ埋め込みベクトル</strong>を作る。</li>
<li>各コミュニティは、そのコミュニティ内の多くのユーザがフォローしているインフルエンサー集合によって特徴づけられる。</li>
<li>異質(Heterogeneous)な推薦コンテンツ(i.e.&nbsp;table 1のターゲット)のそれぞれは、<strong>コミュニティ空間におけるベクトル</strong>として表され、アイテム <span class="math inline">\(j\)</span> に対する <span class="math inline">\(i\)</span> 番目のコミュニティに対応する要素は、<span class="math inline">\(i\)</span>番目のコミュニティがアイテム <span class="math inline">\(j\)</span> にどれだけ興味を持っているかを示している。</li>
<li>最終的には、<strong>異質な推薦対象を、同じ空間のスパースで解釈可能なベクトルとして表現でき</strong>、様々な推薦やパーソナライゼーションタスクに活用可能。</li>
</ul>
</section>
</section>
<section id="技術や手法の肝は" class="level1">
<h1>技術や手法の肝は?</h1>
<p>SimClustersシステム(図1参照)は、2つのstageで構成されている：</p>
<ul>
<li>stage 1: Communityの発見 (User Interest Representationsの取得)</li>
<li>stage 2: 各種 Item Representationsの取得</li>
</ul>
<section id="技術や手法の肝は-1" class="level2">
<h2 class="anchored" data-anchor-id="技術や手法の肝は-1">技術や手法の肝は?</h2>
<p>SimClustersシステム(図1参照)は、2つのstageで構成されている：</p>
<p><img src="https://imgur.com/z51bkNj.png" class="img-fluid"></p>
</section>
<section id="stage-1-communityの発見-user-interest-representationsの取得" class="level2">
<h2 class="anchored" data-anchor-id="stage-1-communityの発見-user-interest-representationsの取得">stage 1: Communityの発見 (User Interest Representationsの取得)</h2>
<ul>
<li>stage 1 は、Twitterのユーザとユーザのグラフからコミュニティを発見する</li>
<li>ここで言う”グラフ”とは、<strong>ユーザ間のフォロー関係を表す有向グラフ</strong>(directed graph)の事。</li>
<li>代表的な既存研究に習って、有向グラフを<strong>二部グラフ(bi-partite graph)として再定義</strong>して扱う</li>
</ul>
</section>
<section id="二部グラフbi-partite-graphってなんだっけ" class="level2">
<h2 class="anchored" data-anchor-id="二部グラフbi-partite-graphってなんだっけ">二部グラフ(bi-partite graph)ってなんだっけ?</h2>
<blockquote class="blockquote">
<p>数学、とくにグラフ理論における2部グラフ(にぶグラフ、英: bipartite graph)とは、<strong>頂点集合を2つに分割</strong>して、<strong>各部分の頂点が互いに隣接しない</strong>ようにできるグラフのこと. 互いに隣接しない頂点からなる集合を<strong>独立集合</strong>といい、頂点集合を n 個の独立集合に分割可能なグラフのことを n 部グラフ (n-partite graph) という. (wikipediaより)</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Simple-bipartite-graph.svg/330px-Simple-bipartite-graph.svg.png" class="img-fluid"></p>
</section>
<section id="stage-1-における問題設定を定義" class="level2">
<h2 class="anchored" data-anchor-id="stage-1-における問題設定を定義">stage 1 における問題設定を定義:</h2>
<ul>
<li>左の独立集合<span class="math inline">\(L\)</span>と右の独立集合<span class="math inline">\(R\)</span>を持つ<strong>user–user二部グラフ</strong>(=各頂点がユーザを意味する二部グラフ)が与えられるとする.</li>
<li>そのグラフから<strong><span class="math inline">\(k\)</span>個のコミュニティを発見</strong> し、各左ノード(=<span class="math inline">\(L\)</span>の各頂点)と右ノード(=<span class="math inline">\(R\)</span>の各頂点)にそのメンバーシップの強さ(=<strong>k個の各コミュニティに所属する度合いの強さ</strong>)を示す重みをつけてコミュニティに割り当てる。</li>
</ul>
</section>
<section id="ユーザフォローの有向グラフを二部グラフとして再定義する利点" class="level2">
<h2 class="anchored" data-anchor-id="ユーザフォローの有向グラフを二部グラフとして再定義する利点">ユーザフォローの有向グラフを二部グラフとして再定義する利点</h2>
<ul>
<li>ユーザ-&gt;ユーザのフォロー関係を表す有向グラフを、二部グラフとして再定義する一つの利点は、 <span class="math inline">\(R\)</span> を <span class="math inline">\(L\)</span> と異なるように選択できること。(i.e.&nbsp;全ユーザ集合を２つに集合に分けられる事?<span class="emoji" data-emoji="thinking">🤔</span>)</li>
<li>特に、典型的なソーシャルネットワークの<strong>大部分の辺は少数のユーザに向けられている</strong>(=多くの一般ユーザがインフルエンサー的なユーザをフォローしている状況<span class="emoji" data-emoji="thinking">🤔</span>)ので**、<span class="math inline">\(L\)</span> よりも小さな <span class="math inline">\(R\)</span> を選ぶことは理にかなっている(グラフからコミュニティを発見する上で<span class="emoji" data-emoji="thinking">🤔</span>).</li>
<li>Twitterの場合、最もフォローされている上位<span class="math inline">\(10^7\)</span>人のユーザ(=インフルエンサー)を <span class="math inline">\(R\)</span> に含め、残りの全てのユーザを <span class="math inline">\(L\)</span> に含める.</li>
<li>(文脈から判断すると”有向グラフ→二部グラフに再定義”というのは、まずフォロー関係の有向グラフから<span class="math inline">\(R\)</span>と<span class="math inline">\(L\)</span>の2つのユーザ集合を定義する。次に<span class="math inline">\(R\)</span>内 &amp; <span class="math inline">\(L\)</span>内のノード間のエッジ=辺を切り、二部グラフとして再定義させる、という方法っぽい<span class="emoji" data-emoji="thinking">🤔</span>)</li>
</ul>
</section>
<section id="定義したstage1の問題をどんなアプローチで解く" class="level2">
<h2 class="anchored" data-anchor-id="定義したstage1の問題をどんなアプローチで解く">定義したstage1の問題をどんなアプローチで解く?</h2>
<p>user–user二部グラフからk個のコミュニティを発見し、各ユーザに対してk個のコミュニティに所属する度合いの強さを表す埋め込み表現を取得する為に、次の<strong>3 step</strong> のアプローチを採用している。</p>
<ul>
<li>Step 1. Similarity Graph of Right Nodes: 右の独立集合<span class="math inline">\(R\)</span>について、<strong>類似度グラフ(Similarity Graph)</strong>を取得する.</li>
<li>Step 2. Communities of Right Nodes: <span class="math inline">\(R\)</span>の類似度グラフから、<strong>k個のコミュニティを発見</strong>する(=<span class="math inline">\(R\)</span>のユーザ達をk個のコミュニティに割り当てる).</li>
<li>Step 3. Communities of Left Nodes: 左の独立集合<span class="math inline">\(L\)</span>の各ノード(=頂点=ユーザ)を、Step 2で発見した各コミュニティに割り当てる(=<strong>ユーザと各コミュニティとの関連度合い</strong>を埋め込む).</li>
</ul>
</section>
<section id="定義したstage1の問題をどんなアプローチで解く-1" class="level2">
<h2 class="anchored" data-anchor-id="定義したstage1の問題をどんなアプローチで解く-1">定義したstage1の問題をどんなアプローチで解く?</h2>
<p><img src="https://imgur.com/fWXvC2z.png" class="img-fluid"></p>
</section>
<section id="stage1-step1-右の独立集合rのsimilarityグラフを作る-①作り方" class="level2">
<h2 class="anchored" data-anchor-id="stage1-step1-右の独立集合rのsimilarityグラフを作る-①作り方">stage1-step1: 右の独立集合<span class="math inline">\(R\)</span>のSimilarityグラフを作る ①作り方</h2>
<ul>
<li>このステップの目的は、右の独立集合<span class="math inline">\(R\)</span>のノードを用いて、より小さな uni-partite(一部)の無向グラフ <span class="math inline">\(G\)</span> を構築する事.</li>
<li><span class="math inline">\(R\)</span> 内の2つのユーザ(<span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>)間の重み(=similarityとして表される)を、二部グラフの左側(独立集合 <span class="math inline">\(L\)</span>)の”フォロワーのコサイン類似度”に基づいて定義する.</li>
</ul>
<p><span class="math display">\[
similarity(u, v) = \vec{x_u} \cdot \vec{x_v} / \sqrt{|\vec{x_u}||\vec{x_v}|}
\]</span></p>
<ul>
<li>“フォロワーのコサイン類似度”について具体的には、ユーザuとvについての”フォロワーのbinary incidence vectors(入射ベクトル)“をそれぞれ <span class="math inline">\(\vec{x_u}\)</span> と <span class="math inline">\(\vec{x_v}\)</span> とする(=長さは左集合 <span class="math inline">\(L\)</span> の大きさ.もし<span class="math inline">\(L\)</span>のユーザiが<span class="math inline">\(u\)</span>をフォローしていれば i番目の要素が1, それ以外が0であるようなbinaryベクトル).</li>
</ul>
</section>
<section id="stage1-step1-右の独立集合rのsimilarityグラフを作る-②dense過ぎるsimilarityグラフを生成しない工夫" class="level2">
<h2 class="anchored" data-anchor-id="stage1-step1-右の独立集合rのsimilarityグラフを作る-②dense過ぎるsimilarityグラフを生成しない工夫">stage1-step1: 右の独立集合<span class="math inline">\(R\)</span>のSimilarityグラフを作る ②dense過ぎるsimilarityグラフを生成しない工夫</h2>
<ul>
<li>定義によれば、2つのユーザは、二部グラフにおいて一人以上の共通の隣人(<span class="math inline">\(L\)</span>内のフォロワー)を共有するだけで、非ゼロの類似度がある.(=similarityグラフを行列で表した時の非ゼロ要素!)
<ul>
<li>i.e.&nbsp;similarityグラフ <span class="math inline">\(G\)</span> にエッジ(=ノード間の接続=辺)を持つことになる.</li>
</ul></li>
<li>極端に密な similarityグラフ を生成しないために、similarityスコアがある閾値より低いエッジ(=接続)を破棄する。</li>
<li>さらに、各ノードのsimilarityスコアが最も大きいノードを最大で一定数のみ保持するようにする。</li>
</ul>
</section>
<section id="stage1-step1-右の独立集合rのsimilarityグラフを作る-③このステップの利点" class="level2">
<h2 class="anchored" data-anchor-id="stage1-step1-右の独立集合rのsimilarityグラフを作る-③このステップの利点">stage1-step1: 右の独立集合<span class="math inline">\(R\)</span>のSimilarityグラフを作る ③このステップの利点</h2>
<ul>
<li>twitterでの運用においてstep1は、<span class="math inline">\(~10^9\)</span> 個のノードと<span class="math inline">\(∼10^{11}\)</span>個のエッジを持つ有向/二部グラフを入力とし、<span class="math inline">\(~10^7\)</span> 個のノード(=独立集合<span class="math inline">\(R\)</span>の要素数)と <span class="math inline">\(~10^9\)</span> 個のエッジを持つ無向のsimilarityグラフを出力する。</li>
<li>つまり、<strong>shared-nothing のcluster-computingスケール</strong>から、<strong>shared-memory のmulti-coreスケール</strong>に変換する事ができた。</li>
<li>(=&gt;step1によりグラフのスケールが大幅に削減された事で、複数のリソースにまたがる分散処理ではなく、一つのリソース内で共有メモリを使用するようなマルチコア処理で計算可能になった、って事か<span class="emoji" data-emoji="thinking">🤔</span>)</li>
</ul>
</section>
<section id="stage1-step2-rのsimilarityグラフからk個のコミュニティを発見する" class="level2">
<h2 class="anchored" data-anchor-id="stage1-step2-rのsimilarityグラフからk個のコミュニティを発見する">stage1-step2: <span class="math inline">\(R\)</span>のSimilarityグラフから、k個のコミュニティを発見する</h2>
<ul>
<li>step1で得られた無向のSimilarityグラフを用いて、step2では、<strong>密に接続されたノード集合のコミュニティを発見する</strong>ことを目的としている.</li>
<li>コミュニティ発見アルゴリズムの長い歴史にもかかわらず、twitterのスケーラビリティ要件を満たすことができる既存のソリューションを見つけることができなかった.</li>
<li>今回の要求を満たすために、<strong>Neighborhood-aware Metropolis Hastings(以下、Neighborhood-aware MH)</strong>というアルゴリズムを開発し、similarityグラフからk個のコミュニティを発見し各<span class="math inline">\(R\)</span>ノードを割り当てる。</li>
<li>(ココを話すと時間が足りないので今回は割愛します…!気になった方は<a href="https://qiita.com/morinota/items/d36421df083df9394bad">このqiita記事</a>に、pythonによるテストコードと実装を載せています)</li>
<li>(ベイジアンアプローチの文脈で聞いたことある”Metropolis-Hastings”なので、サンプリング的な事を行って目的関数を元に最適なk個のコミュニティを探索する…!みたいなアプローチ<span class="emoji" data-emoji="thinking">🤔</span>)</li>
</ul>
</section>
<section id="stage1-step3-左の独立集合lの各ノード頂点ユーザをstep-2で発見した各コミュニティに割り当てる①" class="level2">
<h2 class="anchored" data-anchor-id="stage1-step3-左の独立集合lの各ノード頂点ユーザをstep-2で発見した各コミュニティに割り当てる①">stage1-step3: 左の独立集合<span class="math inline">\(L\)</span>の各ノード(=頂点=ユーザ)を、Step 2で発見した各コミュニティに割り当てる①</h2>
<ul>
<li>step2の出力は、右集合<span class="math inline">\(R\)</span>(i.e.&nbsp;インフルエンサー達)に対するコミュニティ割り当て行列 <span class="math inline">\(V_{|R| \times k}\)</span> である. (<span class="math inline">\(i\)</span> 行目の行ベクトルは、右ノード<span class="math inline">\(i\)</span>に割り当てられたコミュニティを示すbinary要素のベクトル.)</li>
<li>stage1の問題設定において残りの問題は、左集合<span class="math inline">\(L\)</span>に対するコミュニティ割り当て行列 <span class="math inline">\(U_{|L| \times k}\)</span> を取得する事.</li>
</ul>
</section>
<section id="stage1-step3-左の独立集合lの各ノード頂点ユーザをstep-2で発見した各コミュニティに割り当てる②方法" class="level2">
<h2 class="anchored" data-anchor-id="stage1-step3-左の独立集合lの各ノード頂点ユーザをstep-2で発見した各コミュニティに割り当てる②方法">stage1-step3: 左の独立集合<span class="math inline">\(L\)</span>の各ノード(=頂点=ユーザ)を、Step 2で発見した各コミュニティに割り当てる②方法</h2>
<ul>
<li>シンプルに、<span class="math inline">\(L\)</span>の各ノードの<strong>neighbors(=全て右集合<span class="math inline">\(R\)</span>のノードのはず!)が割り当てられているコミュニティを集約</strong>する事によって、各左ノード(=一般ユーザ)をコミュニティに割り当てる:</li>
</ul>
<p><span class="math display">\[
U = truncate(A\cdot V)
\]</span></p>
<p>ここで、<span class="math inline">\(A_{|L| \times |R|}\)</span> を<strong>入力二部グラフの隣接行列(adjacency matrix)</strong>(要素=1だと隣接してる事を示すbinary行列.)とする. <span class="math inline">\(truncate()\)</span> 関数は、<strong>任意の1ユーザが所属するコミュニティの数を制限するfunction</strong>(ストレージを節約するため).</p>
<p>得られた<span class="math inline">\(U_{|L| \times k}\)</span>を <strong>User Interest Representations</strong> と呼び、<span class="math inline">\(U\)</span>を入力としてstage2にて、各種アイテムのSimClusters表現を取得する。</p>
</section>
<section id="stage-2-各種-item-representationsの取得①計算方法" class="level2">
<h2 class="anchored" data-anchor-id="stage-2-各種-item-representationsの取得①計算方法">stage 2: 各種 Item Representationsの取得①計算方法</h2>
<ul>
<li>stage2では、ツイート、ハッシュタグ、ユーザなど、<strong>様々な推薦問題の対象となりうるアイテムに対するSimCluters表現</strong>を計算する。</li>
<li>stage2の一般的な枠組みは、<strong>アイテムに関わったすべてのuser interest Representationsを集約</strong>してアイテムの表現を計算すること(なるほど…!シンプル!). つまり、アイテム <span class="math inline">\(j\)</span> のSimClusters表現は、以下.</li>
</ul>
<p><span class="math display">\[
W(j) = aggregate({U(u), \forall u \in N(j)})
\tag{3}
\]</span></p>
<p>ここで、<span class="math inline">\(N(j)\)</span> は、対応するユーザ-アイテム二部グラフにおいてアイテム<span class="math inline">\(j\)</span>に関与したすべてのユーザを示し、<span class="math inline">\(W(j)\)</span> と <span class="math inline">\(U(u)\)</span> はいずれもベクトルである。本手法では、<strong><span class="math inline">\(aggregate()\)</span>関数として”exponentially time-decayed average(指数関数的 時間減衰 平均)“を選択</strong>。これは、アイテムに関わったユーザの貢献度を、そのユーザがアイテムに関わった時間に基づいて指数関数的に減衰させる。(半減期はアイテムのshelf-lifeに応じて設定.)</p>
</section>
<section id="stage-2-各種-item-representationsの取得-②スケーラビリティの工夫" class="level2">
<h2 class="anchored" data-anchor-id="stage-2-各種-item-representationsの取得-②スケーラビリティの工夫">stage 2: 各種 Item Representationsの取得 ②スケーラビリティの工夫</h2>
<ul>
<li>aggregateの結果として得られるベクトル<span class="math inline">\(W\)</span>は<span class="math inline">\(U\)</span>よりもはるかに密度が高く(=&gt;<span class="math inline">\(U\)</span>はsparseが、<span class="math inline">\(W\)</span>の場合はdenceになりうる<span class="emoji" data-emoji="thinking">🤔</span>)、その非ゼロ値をすべてスケールで保存することは有益ではない。</li>
<li><span class="math inline">\(W\)</span>のview (指標、サブセット、要約統計量的なイメージ?)を2つ追加する。
<ul>
<li>first view は<span class="math inline">\(R\)</span>で、<span class="math inline">\(R(j)\)</span>は<strong>アイテム<span class="math inline">\(j\)</span>のトップ<span class="math inline">\(k\)</span>コミュニティを追跡する</strong>.</li>
<li>second viewは<span class="math inline">\(C\)</span>で、<span class="math inline">\(C(c)\)</span>は<strong>コミュニティ<span class="math inline">\(c\)</span>のトップ<span class="math inline">\(k\)</span>アイテムを追跡する</strong>.</li>
</ul></li>
<li>賞味期限が長いものの場合、W、R、Cの計算はbatch処理で行える.</li>
<li>賞味期限が短いものの場合、W、R、Cの計算は、incremental更新を行う.(時間減衰 平均的なアプローチなので、“現在の平均値”と”最後に更新されたtimestamp”さえ保存していれば、新しいユーザとアイテムのengagementログを受け取って<span class="math inline">\(W\)</span>を更新できる…!<span class="emoji" data-emoji="thinking">🤔</span>)</li>
</ul>
</section>
<section id="stage-2-各種-item-representationsの取得-③最終的な成果物" class="level2">
<h2 class="anchored" data-anchor-id="stage-2-各種-item-representationsの取得-③最終的な成果物">## stage 2: 各種 Item Representationsの取得 ③最終的な成果物</h2>
<p>最終的には、stage1で得た<strong>user interest表現</strong>に加えて以下のSimClusters表現<span class="math inline">\(W\)</span>が得られる.(各<span class="math inline">\(W\)</span>について、サブセットとして<span class="math inline">\(R\)</span>や<span class="math inline">\(C\)</span>も保持して活用する。)</p>
<ul>
<li><strong>ツイート表現</strong>: ツイートがどのコミュニティと関連性が強いかを表す埋め込みベクトル</li>
<li><strong>トピック表現</strong>: (上に同じ)</li>
<li><strong>トレンド表現</strong>: (上に同じ)</li>
<li><strong>user influence表現</strong>: ユーザがどのコミュニティで影響を発揮しているかを表すベクトル.
<ul>
<li>user interest表現(=stage1の出力)は、ユーザがどのようなコミュニティに興味を持っているかを表すベクトル.</li>
<li>インフルエンサーのuser interest表現<span class="math inline">\(V\)</span>よりも密である為、優れているらしい。</li>
</ul></li>
</ul>
</section>
<section id="twitterにおける活用例-①ツイート詳細ページでの類似ツイートの推薦" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける活用例-①ツイート詳細ページでの類似ツイートの推薦">twitterにおける活用例 ①ツイート詳細ページでの類似ツイートの推薦</h2>
<ul>
<li>SimClustersの前は、作者の類似性(ページ上のメインツイートの作者と多くのフォロワーを共有するユーザーが書いたツイート)にのみ基づいてツイートを検索していた.</li>
<li><strong>ツイートのSimClusters表現</strong>に基づく類似ツイートを追加した. i.e.&nbsp;SimClusters表現(=どのcommunityと関連度が高いかを表すベクトル)がページ上のメインツイートの表現と高いコサイン類似度を持つツイートを取得した. -&gt; ツイートに対するエンゲージメント率が25％高くなった。</li>
<li>更に、SimClusters表現の２つ目の活用を追加: SimClusters表現が、ページ上のメインツイートの著者の<strong>user influence表現</strong>(=ユーザがどのコミュニティで影響を発揮しているかを表すベクトル)と高いコサイン類似性を持つツイートを検索する. -&gt; 更に全体のエンゲージメント率が7%向上。</li>
</ul>
</section>
<section id="twitterにおける活用例-②home-フィードにおけるツイート推薦" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける活用例-②home-フィードにおけるツイート推薦">twitterにおける活用例 ②Home フィードにおけるツイート推薦</h2>
<ul>
<li>SimClusters以前は、閲覧ユーザのフォローユーザ達が「いいね」を付けているツイートを主なcandidate sourceとしていた。</li>
<li><strong>ツイートのSimClusters表現</strong>を使って、新たに２つのcandidate sourcesを構築し、A/Bテストで新しいcandidateのエンゲージメント率が33%高い結果となった.
<ul>
<li>1つ目: ツイートのSimClusters表現が、<strong>閲覧ユーザのinterest表現</strong>とのドット積が最も高いツイートを特定する.</li>
<li>2つ目: 閲覧ユーザが最近「いいね」したツイートと類似するツイートを特定する.(類似ツイートと同様のアプローチ.)</li>
</ul></li>
<li>candidateの生成とは別に、ユーザやツイートのSimClusters表現を、candidateをソートするDNNランキングモデルの<strong>特徴量として追加</strong>する事も有効だった。(CTR等を目的変数とした教師有りMLモデル)</li>
</ul>
</section>
<section id="twitterにおける活用例-③トレンドランキングのパーソナライズ" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける活用例-③トレンドランキングのパーソナライズ">twitterにおける活用例 ③トレンドランキングのパーソナライズ</h2>
<ul>
<li>Trends(ハッシュタグ、イベント、ニュース速報等の表示)の実装は、Trends候補の検出とランキングの2段階を踏んでいる。</li>
<li><strong>トレンドのSimClusters表現</strong>を使って、user interest表現とリアルタイムのtrend表現のdot product(内積!)を使用することで、与えられたユーザ-トレンドペアをスコア化した.</li>
</ul>
</section>
<section id="twitterにおける活用例-④topic-tweetの推薦" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける活用例-④topic-tweetの推薦">twitterにおける活用例 ④Topic Tweetの推薦</h2>
<ul>
<li>「ファッション」や「マーベル映画」など、あらかじめ定義されたトピック(NPにおけるキーワードの様な概念<span class="emoji" data-emoji="thinking">🤔</span>)に関するコンテンツを表示する機能。</li>
<li>SimClusters以前は、人間の専門家がキュレーションしたテキストマッチングルールに依存して、トピックツイートを識別していた(要するにルールベースの手法だった<span class="emoji" data-emoji="thinking">🤔</span>)</li>
<li>多くのご検出(主にツイートのテキストがトピックのルールと偶然一致することによる)があったらしい。</li>
<li>-&gt;今回SimClusters表現を用いて、<strong>対象トピックのSimClusters表現</strong>と高いコサイン類似度を持つツイート表現を特定する. 次に既存のテキストマッチング規則を適用した. (<strong>二段階にしたって事か</strong><span class="emoji" data-emoji="thinking">🤔</span>)</li>
</ul>
</section>
<section id="twitterにおける活用例-⑤ユーザフォローの推薦" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける活用例-⑤ユーザフォローの推薦">twitterにおける活用例 ⑤ユーザフォローの推薦</h2>
<ul>
<li>Who To Followレコメンデーションの候補は、エンゲージメント予測モデルを用いてランク付けされる.</li>
<li>このモデルには、<strong>閲覧ユーザと候補ユーザのSimClusters表現</strong>に基づく新しい特徴量が加えられている.(特徴量としての活用.)</li>
<li>A/Bテストでは、これらの新たな特徴量を使用することで、フォロー率が7％向上することが確認された.</li>
</ul>
</section>
<section id="twitterにおける今後の活用-①通知品質フィルター" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける今後の活用-①通知品質フィルター">twitterにおける今後の活用 ①通知品質フィルター</h2>
<ul>
<li>Twitterプロダクトの重要なタスクとして、罵倒やスパム的なリプライやメンションを受けないようにユーザを保護することがある.</li>
<li><strong>ユーザとユーザのブロックグラフ（あるユーザーが他のユーザーをブロックした場合）に基づく新しいユーザ表現をSimClustersで開発</strong>し、この表現を特徴として、罵倒やスパムのような返信をフィルタリングするモデルを学習した.</li>
<li>オフラインテストでは、PR-AUC が 4％向上するという素晴らしい結果を示した.</li>
</ul>
</section>
<section id="twitterにおける今後の活用-②リアルタイムイベント通知" class="level2">
<h2 class="anchored" data-anchor-id="twitterにおける今後の活用-②リアルタイムイベント通知">twitterにおける今後の活用 ②リアルタイムイベント通知</h2>
<ul>
<li>リアルタイムイベント通知とは、大きなニュースが起こったときに、興味を持ちそうなユーザに通知すること.(プッシュ通知みたいなこと?<span class="emoji" data-emoji="thinking">🤔</span>)</li>
<li>イベントのSimClusters表現(これは、そのイベントに関する人間が作成したツイート表現をaggregateすることで得られる)を使って、<strong>そのイベントに興味を持つユーザのコミュニティを特定</strong>し、そのコミュニティに興味を持つユーザをターゲットにすることができる.</li>
<li>(新規アイテムの場合は、そのアイテムの属性情報と類似したツイート表現や、作成者のUser表現を使ったら、aggregateして<strong>新規アイテムのSimCluters表現</strong>を作れるだろうか…?<span class="emoji" data-emoji="thinking">🤔</span>)</li>
</ul>
</section>
<section id="まとめと感想" class="level2">
<h2 class="anchored" data-anchor-id="まとめと感想">まとめと感想</h2>
<ul>
<li>Twitterの多種の推薦機能で活躍してるらしい、SimClutersの論文読んだ。</li>
<li>異質な推薦機能で使える、共通基盤的な埋め込みベクトルは便利そう…!<span class="emoji" data-emoji="thinking">🤔</span></li>
<li>NPは経済ニュースサービスだけでなくSNSとしての側面もあるので、ユーザフォローの情報から”ユーザの嗜好”を抽出できるのでは?? <span class="emoji" data-emoji="thinking">🤔</span></li>
<li>特に、NPの場合は<strong>プロピッカー</strong>(公式コメンテータ的な専門家ユーザ)という概念があるので、「このプロピッカーをフォローしてる」情報は活用できるのでは…!<span class="emoji" data-emoji="thinking">🤔</span></li>
<li>ただ、NPの場合はユーザフォロー機能を使ってるユーザが少ない印象. コメントへの”いいね”や”pick”のリアクションをユーザフォローの代替としてネットワークグラフを作成できるのでは…?<span class="emoji" data-emoji="thinking">🤔</span></li>
</ul>
</section>
</section>
<section id="参考-1" class="level1">
<h1>参考:</h1>
<ul>
<li><a href="https://www.kdd.org/kdd2020/accepted-papers/view/simclusters-community-based-representations-for-heterogeneous-recommendatio">SimClustersの論文</a></li>
<li><a href="https://blog.twitter.com/engineering/en_us/topics/open-source/2023/twitter-recommendation-algorithm">公開されたtechブログ</a></li>
<li><a href="https://github.com/twitter/the-algorithm">公開されたgithub リポジトリ</a></li>
<li>n週連続 推薦システム関連の論文読んだシリーズ13週目(毎週水曜更新):<a href="https://qiita.com/morinota/items/d36421df083df9394bad">twitterの様々な推薦機能で活用されてるらしい、ユーザ-ユーザのフォローネットワークからコミュニティ埋め込み表現を生成するSimClustersの論文を読んだ</a></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config);
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>
