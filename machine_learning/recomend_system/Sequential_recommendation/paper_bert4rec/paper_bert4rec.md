## link

https://arxiv.org/abs/1904.06690

## title

BERT4Rec: Sequential Recommendation with Bidirectional Encoder Representations from Transformer

## abstract

Modeling users’ dynamic preferences from their historical behaviors is challenging and crucial for recommendation systems. Previous methods employ sequential neural networks to encode users’ historical interactions from left to right into hidden representations for making recommendations. Despite their effectiveness, we argue that such left-to-right unidirectional models are sub-optimal due to the limitations including: a) unidirectional architectures restrict the power of hidden representation in users’ behavior sequences; b) they often assume a rigidly ordered sequence which is not always practical. To address these limitations, we proposed a sequential recommendation model called BERT4Rec, which employs the deep bidirectional self-attention to model user behavior sequences. To avoid the information leakage and efficiently train the bidirectional model, we adopt the Cloze objective to sequential recommendation, predicting the random masked items in the sequence by jointly conditioning on their left and right context. In this way, we learn a bidirectional representation model to make recommendations by allowing each item in user historical behaviors to fuse information from both left and right sides. Extensive experiments on four benchmark datasets show that our model outperforms various state-of-the-art sequential models consistently

# Introduction

Accurately characterizing users’ interests lives at the heart of an effective recommendation system. In many real-world applications, users’ current interests are intrinsically dynamic and evolving, influenced by their historical behaviors. For example, one may purchase accessories (e.g., Joy-Con controllers) soon after buying a Nintendo Switch, though she/he will not buy console accessories under normal circumstances. To model such sequential dynamics in user behaviors, various methods have been proposed to make sequential recommendations based on users’ historical interactions [15, 22, 40]. They aim to predict the successive item(s) that a user is likely to interact with given her/his past interactions. Recently, a surge of works employ sequential neural networks, e.g., Recurrent Neural Network (RNN), for sequential recommendation and obtain promising results [7, 14, 15, 56, 58]. The basic paradigm of previous work is to encode a user’s historical interactions into a vector (i.e., representation of user’s preference) using a left-to-right sequential model and make recommendations based on this hidden representation. Despite their prevalence and effectiveness, we argue that such left-to-right unidirectional models are not sufficient to learn optimal representations for user behavior sequences. The major limitation, as illustrated in Figure 1c and 1d, is that such unidirectional models restrict the power of hidden representation for items in the historical sequences, where each item can only encode the information from previous items. Another limitation is that previous unidirectional models are originally introduced for sequential data with natural order, e.g., text and time series data. They often assume a rigidly ordered sequence over data which is not always true for user behaviors in real-world applications. In fact, the choices of items in a user’s historical interactions may not follow a rigid order assumption [18, 54] due to various unobservable external factors [5]. In such a situation, it is crucial to incorporate context from both directions in user behavior sequence modeling. To address the limitations mentioned above, we seek to use a bidirectional model to learn the representations for users’ historical behavior sequences. Specifically, inspired by the success of BERT [6] in text understanding, we propose to apply the deep bidirectional self-attention model to sequential recommendation, as illustrated in Figure 1b. For representation power, the superior results for deep bidirectional models on text sequence modeling tasks show that it is beneficial to incorporate context from both sides for sequence representations learning [6]. For rigid order assumption, our model is more suitable than unidirectional models in modeling user behavior sequences since all items in the bidirectional model can leverage the contexts from both left and right side. However, it is not straightforward and intuitive to train the bidirectional model for sequential recommendation. Conventional sequential recommendation models are usually trained left-to-right by predicting the next item for each position in the input sequence. As shown in Figure 1, jointly conditioning on both left and right context in a deep bidirectional model would cause information leakage, i.e., allowing each item to indirectly “see the target item”. This could make predicting the future become trivial and the network would not learn anything useful. To tackle this problem, we introduce the Cloze task [6, 50] to take the place of the objective in unidirectional models (i.e., sequentially predicting the next item). Specifically, we randomly mask some items (i.e., replace them with a special token [mask]) in the input sequences, and then predict the ids of those masked items based on their surrounding context. In this way, we avoid the information leakage and learn a bidirectional representation model by allowing the representation of each item in the input sequence to fuse both the left and right context. In addition to training a bidirectional model, another advantage of the Cloze objective is that it can produce more samples to train a more powerful model in multiple epochs. However, a downside of the Cloze task is that it is not consistent with the final task (i.e., sequential recommendation). To fix this, during the test, we append the special token “[mask]” at the end of the input sequence to indicate the item that we need to predict, and then make recommendations base on its final hidden vector. Extensive experiments on four datasets show that our model outperforms various state-of-the-art baselines consistently. The contributions of our paper are as follows: • We propose to model user behavior sequences with a bidirectional self-attention network through Cloze task. To the best of our knowledge, this is the first study to introduce deep bidirectional sequential model and Cloze objective into the field of recommendation systems. • We compare our model with state-of-the-art methods and demonstrate the effectiveness of both bidirectional architecture and the Cloze objective through quantitative analysis on four benchmark datasets. • We conduct a comprehensive ablation study to analyze the contributions of key components in the proposed model.

# Related Work

In this section, we will briefly review several lines of works closely related to ours, including general recommendation, sequential recommendation, and attention mechanism.

## General Recommendation

Early works on recommendation systems typically use Collaborative Filtering (CF) to model users’ preferences based on their interaction histories [26, 43]. Among various CF methods, Matrix Factorization (MF) is the most popular one, which projects users and items into a shared vector space and estimate a user’s preference on an item by the inner product between their vectors [26, 27, 41]. Another line of work is item-based neighborhood methods [20, 25, 31, 43]. They estimate a user’s preference on an item via measuring its similarities with the items in her/his interaction history using a precomputed item-to-item similarity matrix. Recently, deep learning has been revolutionizing the recommendation systems dramatically. The early pioneer work is a two-layer Restricted Boltzmann Machines (RBM) for collaborative filtering, proposed by Salakhutdinov et al. [42] in Netflix Prize1 .

One line of deep learning based methods seeks to improve the recommendation performance by integrating the distributed item representations learned from auxiliary information, e.g., text [23, 53], images [21, 55], and acoustic features [51] into CF models. Another line of work seeks to take the place of conventional matrix factorization. For example, Neural Collaborative Filtering (NCF) [12] estimates user preferences via Multi-Layer Perceptions (MLP) instead of inner product, while AutoRec [44] and CDAE [57] predict users’ ratings using Auto-encoder framework.

## Sequential Recommendation

Unfortunately, none of the above methods is for sequential recommendation since they all ignore the order in users’ behaviors. Early works on sequential recommendation usually capture sequential patterns from user historical interactions using Markov chains (MCs). For example, Shani et al. [45] formalized recommendation generation as a sequential optimization problem and employ Markov Decision Processes (MDPs) to address it. Later, Rendle et al. [40] combine the power of MCs and MF to model both sequential behaviors and general interests by Factorizing Personalized Markov Chains (FPMC). Besides the first-order MCs, high-order MCs are also adopted to consider more previous items [10, 11]. Recently, RNN and its variants, Gated Recurrent Unit (GRU) [4] and Long Short-Term Memory (LSTM) [17], are becoming more and more popular for modeling user behavior sequences [7, 14, 15, 28, 37, 56, 58]. The basic idea of these methods is to encode user’s previous records into a vector (i.e., representation of user’s preference which is used to make predictions) with various recurrent architectures and loss functions, including session-based GRU with ranking loss (GRU4Rec) [15], Dynamic REcurrent bAsket Model (DREAM) [58], user-based GRU [7], attention-based GRU (NARM) [28], and improved GRU4Rec with new loss function (i.e., BPR-max and TOP1-max) and an improved sampling strategy [14]. Other than recurrent neural networks, various deep learning models are also introduced for sequential recommendation [3, 22, 33, 49]. For example, Tang and Wang [49] propose a Convolutional Sequence Model (Caser) to learn sequential patterns using both horizontal and vertical convolutional filters. Chen et al. [3] and Huang et al. [19] employ Memory Network to improve sequential recommendation. STAMP captures both users’ general interests and current interests using an MLP network with attention [33].

## Attention Mechanism

Attention mechanism has shown promising potential in modeling sequential data, e.g., machine translation [2, 52] and text classification [? ]. Recently, some works try to employ the attention mechanism to improve recommendation performances and interpretability [28, 33]. For example, Li et al. [28] incorporate an attention mechanism into GRU to capture both the user’s sequential behavior and main purpose in session-based recommendation. The works mentioned above basically treat attention mechanism as an additional component to the original models. In contrast, Transformer [52] and BERT [6] are built solely on multi-head self-attention and achieve state-of-the-art results on text sequence modeling. Recently, there is a rising enthusiasm for applying purely attention-based neural networks to model sequential data for their effectiveness and efficiency [30, 32, 38, 46? ]. For sequential recommendation, Kang and McAuley [22] introduce a two-layer Transformer decoder (i.e., Transformer language model) called SASRec to capture user’s sequential behaviors and achieve state-of-the-art results on several public datasets. SASRec is closely related to our work. However, it is still a unidirectional model using a casual attention mask. While we use a bidirectional model to encode users’ behavior sequences with the help of Cloze task.

# BERT4REC

Before going into the details, we first introduce the research problem, the basic concepts, and the notations in this paper.

## Problem Statement

In sequential recommendation, let U={u1,u2, . . . ,u|U | } denote a set of users, V={v1,v2, . . . ,v|V | } be a set of items, and list Su=[v (u) 1 , . . . ,v (u) t , . . . ,v (u) nu ] denote the interaction sequence in chronological order for user u ∈ U, where v (u) t ∈ V is the item that u has interacted with at time step2 t and nu is the the length of interaction sequence for user u. Given the interaction history Su , sequential recommendation aims to predict the item that user u will interact with at time step nu + 1. It can be formalized as modeling the probability over all possible items for user u at time step nu+1:

## Model Architecture

Here, we introduce a new sequential recommendation model called BERT4Rec, which adopts Bidirectional Encoder Representations from Transformers to a new task, sequential Recommendation. It is built upon the popular self-attention layer, “Transformer layer”. As illustrated in Figure 1b, BERT4Rec is stacked by L bidirectional Transformer layers. At each layer, it iteratively revises the representation of every position by exchanging information across all positions at the previous layer in parallel with the Transformer layer. Instead of learning to pass relevant information forward step by step as RNN based methods did in Figure 1d, self-attention mechanism endows BERT4Rec with the capability to directly capture the dependencies in any distances. This mechanism results in a global receptive field, while CNN based methods like Caser usually have a limited receptive field. In addition, in contrast to RNN based methods, self-attention is straightforward to parallelize. Comparing Figure 1b, 1c, and 1d, the most noticeable difference is that SASRec and RNN based methods are all left-to-right unidirectional architecture, while our BERT4Rec uses bidirectional self-attention to model users’ behavior sequences. In this way, our proposed model can obtain more powerful representations of users’ behavior sequences to improve recommendation performances.

## Transformer Layer

As illustrated in Figure 1b, given an input sequence of length t, we iteratively compute hidden representations h l i at each layer l for each position i simultaneously by applying the Transformer layer from [52]. Here, we stack h l i ∈ R d together into matrix Hl ∈R t×d since we compute attention function on all positions simultaneously in practice. As shown in Figure 1a, the Transformer layer Trm contains two sub-layers, a Multi-Head Self-Attention sub-layer and a Position-wise Feed-Forward Network. Multi-Head Self-Attention. Attention mechanisms have become an integral part of sequence modeling in a variety of tasks, allowing capturing the dependencies between representation pairs without regard to their distance in the sequences. Previous work has shown that it is beneficial to jointly attend to information from different representation subspaces at different positions [6, 29, 52]. Thus, we here adopt the multi-head self-attention instead of performing a single attention function. Specifically, multi-head attention first linearly projects Hl into h subspaces, with different, learnable linear projections, and then apply h attention function in parallel to produce the output representations which are concatenated and once again projected:

$$
\tag{1}
$$

where the projections matrices for each headW Q i ∈ R d×d/h ,W K i ∈ R d×d/h ,WV i ∈ R d×d/h , andW O i ∈ R d×d are learnable parameters. Here, we omit the layer subscript l for the sake of simplicity. In fact, these projection parameters are not shared across the layers. Here, the Attention function is Scaled Dot-Product Attention:

$$
\tag{2}
$$

where query Q, key K, and value V are projected from the same matrix Hl with different learned projection matrices as in Equation 1. The temperature p d/h is introduced to produce a softer attention distribution for avoiding extremely small gradients [16, 52]. Position-wise Feed-Forward Network. As described above, the self-attention sub-layer is mainly based on linear projections. To endow the model with nonlinearity and interactions between different dimensions, we apply a Position-wise Feed-Forward Network to the outputs of the self-attention sub-layer, separately and identically at each position. It consists of two affine transformations with a Gaussian Error Linear Unit (GELU) activation in between:

$$
\tag{3}
$$

where Φ(x) is the cumulative distribution function of the standard gaussian distribution, W (1) ∈ R d×4d , W (2) ∈ R 4d×d , b (1) ∈ R 4d and b (2) ∈ R d are learnable parameters and shared across all positions. We omit the layer subscript l for convenience. In fact, these parameters are different from layer to layer. In this work, following OpenAI GPT [38] and BERT [6], we use a smoother GELU [13] activation rather than the standard ReLu activation. Stacking Transformer Layer. As elaborated above, we can easily capture item-item interactions across the entire user behavior sequence using self-attention mechanism. Nevertheless, it is usually beneficial to learn more complex item transition patterns by stacking the self-attention layers. However, the network becomes more difficult to train as it goes deeper. Therefore, we employ a residual connection [9] around each of the two sublayers as in Figure 1a, followed by layer normalization [1]. Moreover, we also apply dropout [47] to the output of each sub-layer, before it is normalized. That is, the output of each sub-layer is LN(x + Dropout(sublayer(x))), where sublayer(·) is the function implemented by the sub-layer itself, LN is the layer normalization function defined in [1]. We use LN to normalize the inputs over all the hidden units in the same layer for stabilizing and accelerating the network training.

In summary, BERT4Rec refines the hidden representations of each layer as follows:

$$
\tag{4}
$$

$$
\tag{5}
$$

$$
\tag{6}
$$

## Embedding Layer

As elaborated above, without any recurrence or convolution module, the Transformer layer Trm is not aware of the order of the input sequence. In order to make use of the sequential information of the input, we inject Positional Embeddings into the input item embeddings at the bottoms of the Transformer layer stacks. For a given item vi , its input representation h 0 i is constructed by summing the corresponding item and positional embedding.

$$
\tag{}
$$

pi where vi ∈E is the d−dimensional embedding for item vi , pi ∈P is the d−dimensional positional embedding for position index i. In this work, we use the learnable positional embeddings instead of the fixed sinusoid embeddings in [52] for better performances. The positional embedding matrix P ∈ R N ×d allows our model to identify which portion of the input it is dealing with. However, it also imposes a restriction on the maximum sentence length N that our model can handle. Thus, we need to truncate the the input sequence [v1, . . . ,vt ] to the last N items [v u t−N +1 , . . . ,vt ] if t > N.

## Output Layer

After L layers that hierarchically exchange information across all positions in the previous layer, we get the final output HL for all items of the input sequence. Assuming that we mask the item vt at time step t, we then predict the masked items vt base on h L t as shown in Figure 1b. Specifically, we apply a two-layer feed-forward network with GELU activation in between to produce an output distribution over target items:

$$
\tag{7}
$$

where W P is the learnable projection matrix, b P , and b O are bias terms, E ∈ R |V |×d is the embedding matrix for the item set V. We use the shared item embedding matrix in the input and output layer for alleviating overfitting and reducing model size.

## Model Learning

Training. Conventional unidirectional sequential recommendation models usually train the model by predicting the next item for each position in the input sequence as illustrated in Figure 1c and 1d. Specifically, the target of the input sequence [v1, . . . ,vt ] is a shifted version [v2, . . . ,vt+1]. However, as shown in Figure 1b, jointly conditioning on both left and right context in a bidirectional model would cause the final output representation of each item to contain the information of the target item. This makes predicting the future become trivial and the network would not learn anything useful. A simple solution for this issue is to create t − 1 samples (subsequences with next items like ([v1], v2) and ([v1,v2], v3)) from the original length t behavior sequence and then encode each histrical subsequence with the bidirectional model to predict the target item. However, this approach is very time and resources consuming since we need to create a new sample for each position in the sequence and predict them separately. In order to efficiently train our proposed model, we apply a new objective: Cloze task [50] (also known as “Masked Language Model” in [6]) to sequential recommendation. It is a test consisting of a portion of language with some words removed, where the participant is asked to fill the missing words. In our case, for each training step, we randomly mask ρ proportion of all items in the input sequence (i.e., replace with special token “[mask]”), and then predict the original ids of the masked items based solely on its left and right context. For example:

$$
\tag{}
$$

The final hidden vectors corresponding to “[mask]” are fed into an output softmax over the item set, as in conventional sequential recommendation. Eventually, we define the loss for each masked input S ′ u as the negative log-likelihood of the masked targets:

$$
\tag{8}
$$

where S ′ u is the masked version for user behavior history Su , S m u is the random masked items in it, v ∗ m is the true item for the masked item vm, and the probability P(·) is defined in Equation 7. An additional advantage for Cloze task is that it can generate more samples to train the model. Assuming a sequence of length n, conventional sequential predictions in Figure 1c and 1d produce n unique samples for training, while BERT4Rec can obtain n k  samples (if we randomly mask k items) in multiple epochs. It allows us to train a more powerful bidirectional representation model. Test. As described above, we create a mismatch between the training and the final sequential recommendation task since the Cloze objective is to predict the current masked items while sequential recommendation aims to predict the future. To address this, we append the special token “[mask]” to the end of user’s behavior sequence, and then predict the next item based on the final hidden representation of this token. To better match the sequential recommendation task (i.e., predict the last item), we also produce samples that only mask the last item in the input sequences during training. It works like fine-tuning for sequential recommendation and can further improve the recommendation performances.

## Discussion

Here, we discuss the relation of our model with previous related work. SASRec. Obviously, SASRec is a left-to-right unidirectional version of our BERT4Rec with single head attention and causal attention mask. Different architectures lead to different training methods. SASRec predicts the next item for each position in a sequence, while BERT4Rec predicts the masked items in the sequence using Cloze objective. CBOW & SG. Another very similar work is Continuous Bag-ofWords (CBOW) and Skip-Gram (SG) [35]. CBOW predicts a target word using the average of all the word vectors in its context (both left and right). It can be seen as a simplified case of BERT4Rec, if we use one self-attention layer in BERT4Rec with uniform attention weights on items, unshare item embeddings, remove the positional embedding, and only mask the central item. Similar to CBOW, SG can also be seen as a simplified case of BERT4Rec following similar reduction operations (mask all items except only one). From this point of view, Cloze can be seen as a general form for the objective of CBOW and SG. Besides, CBOW uses a simple aggregator to model word sequences since its goal is to learn good word representations, not sentence representations. On the contrary, we seek to learn a powerful behavior sequence representation model (deep selfattention network in this work) for making recommendations. BERT. Although our BERT4Rec is inspired by the BERT in NLP, it still has several differences from BERT: a) The most critical difference is that BERT4Rec is an end-to-end model for sequential recommendation, while BERT is a pre-training model for sentence representation. BERT leverages large-scale task-independent corpora to pre-train the sentence representation model for various text sequence tasks since these tasks share the same background knowledge about the language. However, this assumption does not hold in the recommendation tasks. Thus we train BERT4Rec end-to-end for different sequential recommendation datasets. b) Different from BERT, we remove the next sentence loss and segment embeddings since BERT4Rec models a user’s historical behaviors as only one sequence in sequential recommendation task.

# Experiments

## Datasets

We evaluate the proposed model on four real-world representative datasets which vary significantly in domains and sparsity.

• Amazon Beauty3 : This is a series of product review datasets crawled from Amazon.com by McAuley et al. [34]. They split the data into separate datasets according to the toplevel product categories on Amazon. In this work, we adopt the “Beauty” category. • Steam4 : This is a dataset collected from Steam, a large online video game distribution platform, by Kang and McAuley [22]. • MovieLens [8]: This is a popular benchmark dataset for evaluating recommendation algorithms. In this work, we adopt two well-established versions, MovieLens 1m (ML1m) 5 and MovieLens 20m (ML-20m) 6 .

For dataset preprocessing, we follow the common practice in [22, 40, 49]. For all datasets, we convert all numeric ratings or the presence of a review to implicit feedback of 1 (i.e., the user interacted with the item). After that, we group the interaction records by users and build the interaction sequence for each user by sorting these interaction records according to the timestamps. To ensure the quality of the dataset, following the common practice [12, 22, 40, 49], we keep users with at least five feedbacks. The statistics of the processed datasets are summarized in Table 1.

## Task Settings & Evaluation Metrics

To evaluate the sequential recommendation models, we adopted the leave-one-out evaluation (i.e., next item recommendation) task, which has been widely used in [12, 22, 49]. For each user, we hold out the last item of the behavior sequence as the test data, treat the item just before the last as the validation set, and utilize the remaining items for training. For easy and fair evaluation, we follow the common strategy in [12, 22, 49], pairing each ground truth item in the test set with 100 randomly sampled negative items that the user has not interacted with. To make the sampling reliable and representative [19], these 100 negative items are sampled according to their popularity. Hence, the task becomes to rank these negative items with the ground truth item for each user. Evaluation Metrics. To evaluate the ranking list of all the models, we employ a variety of evaluation metrics, including Hit Ratio (HR), Normalized Discounted Cumulative Gain (NDCG), and Mean Reciprocal Rank (MRR). Considering we only have one ground truth item for each user, HR@k is equivalent to Recall@k and proportional to Precision@k; MRR is equivalent to Mean Average Precision (MAP). In this work, we report HR and NDCG with k = 1, 5, 10. For all these metrics, the higher the value, the better the performance.

## Baselines & Implementation Details

To verify the effectiveness of our method, we compare it with the following representative baselines: • POP: It is the simplest baseline that ranks items according to their popularity judged by the number of interactions. • BPR-MF [39]: It optimizes the matrix factorization with implicit feedback using a pairwise ranking loss. • NCF [12]: It models userâĂŞitem interactions with a MLP instead of the inner product in matrix factorization. • FPMC [40]: It captures users’ general taste as well as their sequential behaviors by combing MF with first-order MCs. • GRU4Rec [15]: It uses GRU with ranking based loss to model user sequences for session based recommendation. • GRU4Rec+ [14]: It is an improved version of GRU4Rec with a new class of loss functions and sampling strategy. • Caser [49]: It employs CNN in both horizontal and vertical way to model high-order MCs for sequential recommendation. • SASRec [22]: It uses a left-to-right Transformer language model to capture users’ sequential behaviors, and achieves state-of-the-art performance on sequential recommendation. For NCF7 , GRU4Rec8 , GRU4Rec+8 , Caser9 , and SASRec10, we use code provided by the corresponding authors. For BPR-MF and FPMC, we implement them using TensorFlow. For common hyperparameters in all models, we consider the hidden dimension size d from {16, 32, 64, 128, 256}, the ℓ2 regularizer from {1, 0.1, 0.01, 0.001, 0.0001}, and dropout rate from {0, 0.1, 0.2, · · · , 0.9}. All other hyper-parameters (e.g., Markov order in Caser) and initialization strategies are either followed the suggestion from the methods’ authors or tuned on the validation sets. We report the results of each baseline under its optimal hyper-parameter settings. We implement BERT4Rec11 with TensorFlow. All parameters are initialized using truncated normal distribution in the range [−0.02, 0.02]. We train the model using Adam [24] with learning rate of 1e-4, β1 = 0.9, β2 = 0.999, ℓ2 weight decay of 0.01, and linear decay of the learning rate. The gradient is clipped when its ℓ2 norm exceeds a threshold of 5. For fair comparison, we set the layer number L = 2 and head number h = 2 and use the same maximum sequence length as in [22], N = 200 for ML-1m and ML-20m, N = 50 for Beauty and Steam datasets. For head setting, we empirically set the dimensionality of each head as 32 (single head if d < 32). We tune the mask proportion ρ using the validation set, resulting in ρ = 0.6 for Beauty, ρ = 0.4 for Steam, and ρ = 0.2 for ML-1m and ML-20m. All the models are trained from scratch without any pre-training on a single NVIDIA GeForce GTX 1080 Ti GPU with a batch size of 256.

## Overall Performance Comparison

Table 2 summarized the best results of all models on four benchmark datasets. The last column is the improvements of BERT4Rec relative to the best baseline. We omit the NDCG@1 results since it is equal to HR@1 in our experiments. It can be observed that: The non-personalized POP method gives the worst performance12 on all datasets since it does not model user’s personalized preference using the historical records. Among all the baseline methods, sequential methods (e.g., FPMC and GRU4Rec+) outperforms non-sequential methods (e.g., BPR-MF and NCF) on all datasets consistently. Compared with BPR-MF, the main improvement of FPMC is that it models users’ historical records in a sequential way. This observation verifies that considering sequential information is beneficial for improving performances in recommendation systems. Among sequential recommendation baselines, Caser outperforms FPMC on all datasets especially for the dense dataset ML-1m, suggesting that high-order MCs is beneficial for sequential recommendation. However, high-order MCs usually use very small order L since they do not scale well with the order L. This causes Caser to perform worse than GRU4Rec+ and SASRec, especially on sparse datasets. Furthermore, SASRec performs distinctly better than GRU4Rec and GRU4Rec+, suggesting that self-attention mechanism is a more powerful tool for sequential recommendation. According to the results, it is obvious that BERT4Rec performs best among all methods on four datasets in terms of all evaluation metrics. It gains 7.24% HR@10, 11.03% NDCG@10, and 11.46% MRR improvements (on average) against the strongest baselines. Question 1: Do the gains come from the bidirectional self-attention model or from the Cloze objective?

To answer this question, we try to isolate the effects of these two factors by constraining the Cloze task to mask only one item at a time. In this way, the main difference between our BERT4Rec (with 1 mask) and SASRec is that BERT4Rec predicts the target item jointly conditioning on both left and right context. We report the results on Beauty and ML-1m with d = 256 in Table 3 due to the space limitation. The results show that BERT4Rec with 1 mask significantly outperforms SASRec on all metrics. It demonstrates the importance of bidirectional representations for sequential recommendation. Besides, the last two rows indicate that the Cloze objective also improves the performances. Detailed analysis of the mask proportion ρ in Cloze task can be found in § 4.6 Question 2: Why and how does bidirectional model outperform unidirectional models? To answer this question, we try to reveal meaningful patterns by visualizing the average attention weights of the last 10 items during the test on Beauty in Figure 2. Due to the space limitation, we only report four representative attention heat-maps in different layers and heads.

We make several observations from the results. a) Attention varies across different heads. For example, in layer 1, head 1 tends to attend on items at the left side while head 2 prefers to attend on items on the right side. b) Attention varies across different layers. Apparently, attentions in layer 2 tend to focus on more recent items. This is because layer 2 is directly connected to the output layer and the recent items play a more important role in predicting the future. Another interesting pattern is that heads in Figure 2a and 2b also tend to attend on [mask]13. It may be a way for self-attention to propagate sequence-level state to the item level. c) Finally and most importantly, unlike unidirectional model can only attend on items at the left side, items in BERT4Rec tend to attend on the items at both sides. This indicates that bidirectional is essential and beneficial for user behavior sequence modeling. In the following studies, we examine the impact of the hyperparameters, including the hidden dimensionality d, the mask proportion ρ, and the maximum sequence length N. We analyze one hyper-parameter at a time by fixing the remaining hyper-parameters at their optimal settings. Due to space limitation, we only report NDCG@10 and HR@10 for the follow-up experiments.
